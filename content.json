{"meta":{"title":"高家祺的博客","subtitle":null,"description":null,"author":"高家祺","url":"https://challange.github.io","root":"/"},"pages":[{"title":"我的架构师之路——书单","date":"2019-04-13T03:37:59.732Z","updated":"2019-04-13T03:37:59.731Z","comments":true,"path":"books/index.html","permalink":"https://challange.github.io/books/index.html","excerpt":"","text":"计算机系统 深入理解计算机系统 深入理解并行编程 深入理解LINUX内核 编码，隐匿在计算机背后的语言 JAVA 码出高效Java开发手册——杨冠宝（孤尽）、高海慧（鸣莎） Mybatis从入门到精通——刘增辉 JAVA性能权威指南——Scott Oaks Java工程师修炼之道 深入理解JVM &amp; G1 GC——周明耀 Java架构师指南 Java微服务 数据结构与算法Java语言描述——Allen B.Downey 图解Java多线程设计模式——结城浩 Effective Java中文版 Spring 5 高级编程 Spring技术内幕——计文柯 Spring源码深度解析——郝佳 SpringCloud微服务实战——翟永超 深入理解SpringCloud与微服务构建——方志明 SpringBoot实战，JavaEE开发的颠覆者 深入实践SpringBoot Kafka权威指南——薛命灯 Elasticsearch源码解析与优化实战——张超 Java核心技术卷1+卷2 Java编程思想(第4版) Java8实战 Java编程的逻辑 Java并发编程的艺术 Java程序员修炼之道 Java常用算法手册 深入理解 Java 虚拟机 架构 图解性能优化 架构探险，从零开始写Java Web框架——黄勇 架构探险，轻量级微服务架构（上）——黄勇 架构探险，轻量级微服务架构（下）——黄勇 架构整洁之道——Martin，孙宇聪 大道至简——软件工程实践者的思想——周爱民 Tomcat架构解析——刘光瑞 Head First 设计模式 分布式服务架构：原理、设计与实践 人人都是架构上：分布式系统架构落地与瓶颈突破 代码整洁之道 Tomcat内核设计剖析——汪建 Head First 软件开发 从零开始学架构——李运华 软件是这样“炼“成的——从软件需求分析到软件架构设计 可伸缩服务架构：框架与中间件 大型分布式网站架构设计与实践 架构即是未来，现代企业可拓展的Web架构、流程和组织 恰如其分的软件架构 设计模式的艺术，软件开发人员内功修炼之道 系统机构，复杂系统的产品设计与开发 分布式服务框架原理与实战 重构，改善既有代码设计 数据库 Redis深度历险，核心原理与应用实践——钱文品 Sql必知必会 SQL优化核心思想 数据建模经典教程 高性能Mysql(第三版) 高性能SQL，调优精要与案例解析——闫书清 SQL学习指南 Neo4j实战 Neo4j全栈开发 图数据库 MongoDB应用设计模式 Mysql排错指南 前端 前端工程化体系设计与实践 前端架构设计 React设计模式与最佳实践——林昊 React状态管理与同构实战——侯策、颜海镜 React进阶之路 新时期的Nodejs入门 Nodejs实战 CSS世界 React学习手册 高效前端：Web高效编程与优化实践 编写可维护的JavaScript Web前端技术 Nodejs与express开发 产品 自传播：为产品注入自发传播的基因 启示录：打造用户喜爱的产品 产品设计与开发 用户故事地图 用户体验可视化指南 用户体验要素——用户为中心的产品设计 其他 C Primer Plus(第五版) 算法图解 CTO说 剑指Offer 编程珠玑 GO语言编程 GO语言学习笔记 逆流而上，阿里巴巴技术成长之路 技术之瞳，阿里巴巴技术笔试心得 明解C语言，入门篇 明解JAVA 像科学家一样思考Python 笨办法学Python Activiti实战 Activiti权威指南 工作流管理-模型、方法和系统 疯狂Workflow讲义，机遇Activiti的工作流应用开发 马云正传，活着就是为了颠覆世界 图解机器学习 图解深度学习 代码之髓 极简人工智能，你一定爱读的AI通识书 区块链技术指南 NodeJs区块链开发 Linux入门很简单 C++面向对象程序设计 Linux入门很简单 Arduino实战指南 Arduino实战案例 Arduino软硬件协同设计实战指南 美团机器学习实战 机器学习实战 机器学习系统设计 科学前沿图谱，知识可视化探索"},{"title":"分类","date":"2019-04-07T07:11:25.010Z","updated":"2019-04-07T05:50:28.000Z","comments":false,"path":"categories/index.html","permalink":"https://challange.github.io/categories/index.html","excerpt":"","text":""},{"title":"资料链接","date":"2019-04-07T07:15:22.545Z","updated":"2019-04-07T07:15:22.543Z","comments":true,"path":"links/index.html","permalink":"https://challange.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-07T07:13:22.859Z","updated":"2019-04-07T05:50:28.000Z","comments":false,"path":"repository/index.html","permalink":"https://challange.github.io/repository/index.html","excerpt":"","text":""},{"title":"错误信息整理","date":"2019-04-07T13:00:38.000Z","updated":"2019-05-05T08:12:33.813Z","comments":true,"path":"problem/index.html","permalink":"https://challange.github.io/problem/index.html","excerpt":"","text":"SpringCloud 1Consider defining a bean of type &apos;org.springframework.http.codec.ServerCodecConfigurer&apos; in your configuration. spring-boot-starter-web与spring-cloud-starter-gateway存在jar包冲突Spring Cloud Gateway 是使用 netty+webflux 实现因此不需要再引入 web 模块。 Spring Cloud Gateway 项目会吞异常日志，需要找到原因 数据库相关 mysql排序稳定性问题 12Cause: java.sql.SQLException: Zero date value prohibitedcom.mysql.cj.core.exceptions.DataReadException: Zero date value prohibited 数据时区错误，由于数据库字段timestamp类型有时间0000-00-00 00:00:00，修改为正常时间即可。timestamp的默认值：CURRENT_TIMESTAMP（插入时个更新时间）、ON UPDATE CURRENT_TIMESTAMP（仅在更新时设置时间，插入时赋值）、CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP （创建和修改时都修改此值） 压测相关1Cause: java.net.NoRouteToHostException: Cannot assign requested address. 系统的连接端口耗尽 前端相关 Http ResponseHeader 中的自定义属性，如果浏览器请求抓包可以看到，但是js中获取不到，则需要检查跨域配置 解决： 响应头Access-Control-Expose-Headers，配置自定义属性，然后就可以获取到了。 问题请求：angular1.6 $http.post原文：http://www.it1352.com/886056.html参考：跨域资源共享 CORS 详解 在react中，setState是异步操作，赋值后不能马上生效。 1The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. 当看到此错误时注意，当前端请求配置credentials: “include”时，后端需要配置”Access-Control-Allow-Credentials”为true，这样才能使带credentials的CORS请求成功。SpringBoot2.0下对跨域的处理方式可以为使用@CrossOrigin注解或者编写配置类实现WebMvcConfigurer接口的addCorsMappings方法。 12345678@Overridepublic void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;POST&quot;,&quot;GET&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true);&#125; React Eslint 报错与警告Do not use setState in componentDidMountcomponentDidMount 执行是在DOM渲染完成后，在这里面使用setState会触发重绘，相当于进行了两次渲染，因此建议在constructor或者componentWillMount中把准备工作做好。当然在componentDidMount 周期异步获取数据并通过setState赋值是正确逻辑。 Arrow function should not return assignment.12case：&lt;div ref=&#123;(el) =&gt; &#123; this.myCustomEl = el &#125;&#125; /&gt; 在使用箭头函数的时候，不应当返回赋值语句。 JSX props should not use arrow functionsA bind call or arrow function in a JSX prop will create a brand new function on every single render. This is bad for performance, as it may cause unnecessary re-renders if a brand new function is passed as a prop to a component that uses reference equality check on the prop to determine if it should update.https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md Expected to return a value in arrow function array-callback-return Linux及生产环境问题磁盘没有空间：Error: ENOSPC: no space left on device, write解决方案：增大磁盘空间或删除迁移没用文件，如日志文件"}],"posts":[{"title":"SpringCloud——Gateway跨域配置","slug":"springcloud-SpringCloud——Gateway跨域配置","date":"2019-05-05T08:05:05.000Z","updated":"2019-05-05T08:15:10.444Z","comments":true,"path":"springcloud-SpringCloud——Gateway跨域配置/","link":"","permalink":"https://challange.github.io/springcloud-SpringCloud——Gateway跨域配置/","excerpt":"","text":"正确配置方法1234567891011121314151617181920/** * 配置跨域 * @return */@Beanpublic CorsWebFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); // cookie跨域 config.setAllowCredentials(Boolean.TRUE); config.addAllowedMethod(\"*\"); config.addAllowedOrigin(\"*\"); config.addAllowedHeader(\"*\"); // 配置前端js允许访问的自定义响应头 config.addExposedHeader(\"setToken\"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(\"/**\", config); return new CorsWebFilter(source);&#125; 配置不生效方法 官方推荐配置 自定义实现GlobalFilter无效","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"SpringCloud——Gateway配置大全","slug":"springcloud-SpringCloud——Gateway配置大全","date":"2019-04-07T08:36:59.000Z","updated":"2019-04-07T08:44:25.545Z","comments":true,"path":"springcloud-SpringCloud——Gateway配置大全/","link":"","permalink":"https://challange.github.io/springcloud-SpringCloud——Gateway配置大全/","excerpt":"","text":"了解Gateway的配置才可以理解使用Gateway可以做什么事情，才能更好地应用在产品开发中。 Predicates Predicates主要起的作用是：配置路由匹配请求的规则 Http相关Path 配置对于请求路径的匹配规则 yml配置，多个参数用逗号隔开 1- Path = /aa/**,/bb/** json配置 1&#123;\"name\":\"Path\",\"args\":&#123;\"pattern\":\"/aa/**\",\"pattern1\":\"/bb/**\"&#125;&#125; Cookie 配置对Cookie中值的匹配，第一个为key，第二个为value。下例匹配cookie设置chocolate:ch.p的请求 yml配置 1- Cookie = chocolate,ch.p json配置 1&#123;\"name\":\"Cookie\",\"args\":&#123;\"_genkey_0\":\"chocolate\",\"_genkey_1\":\"ch.p\"&#125;&#125; Header 匹配Http请求中设置的内容，http-header设置X-Request-Id:\\d+可以匹配，第二个参数第二个参数是正则表达式 yml配置 1- Header = X-Request-Id,\\d+ json配置 1&#123;\"name\":\"Header\",\"args\":&#123;\"_genkey_0\":\"X-Request-Id\",\"_genkey_1\":\"\\d+\"&#125;&#125; Host 匹配Http请求Host，匹配所有host为**.somehost.com的请求 yml配置 1- Host = **.somehost.com json配置 1&#123;\"name\":\"Host\",\"args\":&#123;\"_genkey_0\":\"**.somehost.com\"&#125;&#125; Method 匹配Http请求头 yml配置 1- Method = GET json配置 1&#123;\"name\":\"Method\",\"args\":&#123;\"_genkey_0\":\"GET\"&#125;&#125; Query 匹配Http请求中的查询参数，请求中携带param1=value的请求可以匹配 yml配置 1- Query = param1,value json配置 1&#123;\"name\":\"Query\",\"args\":&#123;\"_genkey_0\":\"param1\",\"_genkey_1\":\"value\"&#125;&#125; RemoteAddr 匹配请求中的RemoteAddr yml配置 1- RemoteAddr = 192.168.1.1/24 json配置 1&#123;\"name\":\"RemoteAddr\",\"args\":&#123;\"_genkey_0\":\"192.168.1.1/24\"&#125;&#125; 时间相关After 设置时间之后可以访问 yml配置 1- After = 2017-01-20T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"After\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"&#125;&#125; Before 设置时间之前可以访问 yml配置 1- Before = 2017-01-20T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"Before\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"&#125;&#125; Before 设置时间段内可以访问 yml配置 1- Between = 2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"Between\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"，\"_genkey_1\":\"2017-01-21T17:42:47.789-07:00[America/Denver]\"&#125;&#125; 权重路由 至少两组以上路由可以配置权重路由，配置后会根据权重随机访问几个路由 yml配置 1- Weight = service1,80 json配置 1&#123;\"name\":\"Weight\",\"args\":&#123;\"_genkey_0\":\"service1\",\"_genkey_1\":\"80\"&#125;&#125; Filters路径重写 yml配置 1- RewritePath = /path/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; json配置 1&#123;\"name\":\"RewritePath\",\"args\":&#123;\"_genkey_0\":\"/foo/(?&lt;segment&gt;.*)\",\"_genkey_1\":\"/$\\\\&#123;segment&#125;\"&#125;&#125; 修改请求头 yml配置 1- AddRequestHeader = X-Request-Foo,Bar json配置 1&#123;\"name\":\"AddRequestHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 修改请求参数 yml配置 1- AddRequestParameter = foo,bar json配置 1&#123;\"name\":\"AddRequestParameter\",\"args\":&#123;\"_genkey_0\":\"foo\",\"_genkey_1\":\"bar\"&#125;&#125; 修改响应参数 yml配置 1- AddResponseHeader = X-Request-Foo,Bar json配置 1&#123;\"name\":\"AddResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 路径前缀增强 请求路径/hello, 将会被替换为 /mypath/hello yml配置 1- PrefixPath = /mypath json配置 1&#123;\"name\":\"PrefixPath\",\"args\":&#123;\"_genkey_0\":\"/mypath\"&#125;&#125; 路径前缀删除 请求/name/bar/foo，去除掉前面两个前缀之后，最后转发到目标服务的路径为/foo yml配置 1- StripPrefix = 2 json配置 1&#123;\"name\":\"StripPrefix\",\"args\":&#123;\"_genkey_0\":\"2\"&#125;&#125; 请求携带保留原始Host yml配置 1- PreserveHostHeader json配置 1&#123;\"name\":\"PreserveHostHeader\",\"args\":&#123;&#125;&#125; 重定向 yml配置 1- RedirectTo = 302,http://acme.org json配置 1&#123;\"name\":\"RedirectTo\",\"args\":&#123;\"_genkey_0\":\"302\",\"_genkey_1\":\"http://acme.org\"&#125;&#125; 断路器 yml配置 12345- name: Hystrix args: # 断路后跳转地址 name: fallbackcmd fallbackUri: forward:/incaseoffailureusethis json配置 1&#123;\"name\":\"Hystrix\",\"args\":&#123;\"name\":\"fallbackcmd\",\"fallbackUri\":\"forward:/incaseoffailureusethis\"&#125;&#125; 集成Redis原生支持请求限流 yml配置 1234- name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 json配置 1&#123;\"name\":\"RequestRateLimiter\",\"args\":&#123;\"redis-rate-limiter.replenishRate\":\"10\",\"redis-rate-limiter.burstCapacity\":\"20\"&#125;&#125; 删除请求头属性 yml配置 1- RemoveRequestHeader = X-Request-Foo json配置 1&#123;\"name\":\"RemoveRequestHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\"&#125;&#125; 删除响应头属性 yml配置 1- RemoveResponseHeader = X-Request-Foo json配置 1&#123;\"name\":\"RemoveResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\"&#125;&#125; 重写响应头 将请求 /42?user=ford&amp;password=omg!what&amp;flag=true, 改为 /42?user=ford&amp;password=***&amp;flag=true yml配置 1- RewriteResponseHeader = X-Response-Foo,password=[^&amp;]+,password=*** json配置 1&#123;\"name\":\"RewriteResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Response-Foo\",\"_genkey_1\":\"password=[^&amp;]+\",\"_genkey_2\":\"password=***\"&#125;&#125; 重设请求路径 请求/foo/bar，在接下来的处理中被改为/bar yml配置 1- SetPath =/&#123;segment&#125; json配置 1&#123;\"name\":\"SetPath\",\"args\":&#123;\"_genkey_0\":\"/&#123;segment&#125;\"&#125;&#125; 设置响应头 在接下来的处理中修改响应头X-Response-Foo为Bar yml配置 1- SetResponseHeader =X-Request-Foo,Bar json配置 1&#123;\"name\":\"SetResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Response-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 设置Http状态 yml配置 123- name: SetStatus args: status: 401 json配置 1&#123;\"name\":\"SetStatus\",\"args\":&#123;\"_genkey_0\":\"302\"&#125;&#125; 设置文件传输大小 yml配置 123- name: RequestSize args: maxSize: 5000000 json配置 1&#123;\"name\":\"RequestSize\",\"args\":&#123;\"_genkey_0\":\"5000000\"&#125;&#125; 失败重试 yml配置1234- name: Retry args: retries: 3 statuses: BAD_GATEWAY","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"从零开始玩转SpringCloud（二）：Gateway网关对接注册中心","slug":"springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心","date":"2019-04-07T06:54:30.000Z","updated":"2019-04-07T06:58:46.810Z","comments":true,"path":"springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心/","link":"","permalink":"https://challange.github.io/springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心/","excerpt":"","text":"简介：Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。 项目搭建 引入依赖12345678910&lt;!--Eureka 客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Gateway 路由--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 注意：不要引入spring-boot-starter-web包，会导致Gateway启动抛出异常，错误如下。因为Spring Cloud Gateway 是使用 netty+webflux实现，webflux与web是冲突的。1Consider defining a bean of type &apos;org.springframework.http.codec.ServerCodecConfigurer&apos; in your configuration. 在Application中使用@EnableEurekaClient 12345678910111213package com.example.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 配置自动将注册中心的服务映射为路由 12345678910111213141516171819server: port: 8081spring: application: name: gateway cloud: gateway: # 此处配置表示开启自动映射Eureka下发的路由 discovery: locator: enabled: true lowerCaseServiceId: trueeureka: client: # Eureka Server地址 service-url: defaultZone: http://localhost:8760/eureka/ 至此，已经可以直接通过gateway访问其他注册在Eureka中的服务的接口了。如客户端接口地址：http://localhost:8080/test，注册名称为client，则访问地址为http://localhost:8081/client/test。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"从零开始玩转SpringCloud（一）：Eureka注册中心","slug":"springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心","date":"2019-04-07T06:50:20.000Z","updated":"2019-04-07T08:53:50.341Z","comments":true,"path":"springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心/","link":"","permalink":"https://challange.github.io/springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心/","excerpt":"","text":"Eureka 介绍：Eureka，古希腊词语，含义为我找到了，我发现了！相传阿基米德发现福利原理时说出了这个词。 Eureka是Spring Cloud Netflix微服务套件中的一部分，可以与Springboot构建的微服务很容易的整合起来。Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端组件包含服务消费者与服务生产者。在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时也可以从服务端查询当前注册的服务信息并把他们缓存到本地并周期性的刷新服务状态。 Eureka-Server服务搭建 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 在Application中使用@EnableEurekaServer 12345678910111213package com.example.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526spring: application: name: eureka-server # cAPP名称，在Eureka注册名称 profiles: active: peer eureka: instance: hostname: peer # 服务注册中心实例的主机名 client: register-with-eureka: false # 是否注册自己 fetch-registry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ server: enableSelfPreservation: false #关闭自我保护机制logging: level: com: netflix: eureka: info discovery: infoserver: port: 8760 至此一个Eureka-Server就搭建好了。 Eureka-Server服务高可用 说到高可用，就是要保证一个节点挂掉，不会影响整个系统的运行。解决办法就是多部署几个实例，搭建集群，那么一个实例节点挂掉，其他实例仍可提供服务。 新建三个配置文件application-peer1.yml、application-peer2.yml、application-peer3， 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer1eureka: instance: hostname: peer1 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8762/eureka, http://localhost:8763/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: infoserver: port: 8761 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer2eureka: instance: hostname: peer2 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8761/eureka, http://localhost:8763/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: info server: port: 8762 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer3eureka: instance: hostname: peer3 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8761/eureka, http://localhost:8762/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: infoserver: port: 8763 idea下按配置文件启动多个项目，Active profiles指定启动配置文件。分别启动刚刚写好的三个配置文件即可。 生产环境下是否需要动态配置注册中心，目前的配置对生产环境动态配置非常不友好 客户端配置 引入Eureka Client依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在Application中使用@EnableEurekaServer 12345678910111213package com.example.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaClient@SpringBootApplicationpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 配置文件 12345678910111213spring: application: name: gateway # 在eureka-server注册名称 eureka: client: service-url: defaultZone: http://localhost:8760/eureka/ # #高可用配置# defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/,http://localhost:8763/eureka/ server: port: 8081 至此已EurekaClient已经搭建成功","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://challange.github.io/tags/Eureka/"}]},{"title":"Scratch3.0——项目层次结构","slug":"scratch-Scratch3-0——项目层次结构","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T09:05:43.386Z","comments":true,"path":"scratch-Scratch3-0——项目层次结构/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——项目层次结构/","excerpt":"","text":"简要介绍: 本文旨在介绍scratch3.0项目层次结构及关键功能。源码：https://github.com/LLK/scratch-gui 核心依赖库scratch-audio：声音拓展scratch-blocks：代码积木块scratch-l10n：国际化scratch-paint：绘图拓展scratch-render：舞台渲染，在舞台区域出现的基于WebGL的处理器。scratch-storage：作品存储加载scratch-svg-renderer：svg处理scratch-vm：虚拟机，管理状态并执行业务逻辑。 Scratch-Gui目录结构在scratch中最为核心的便是gui库，目录结构如下：123456789101112131415161718192021222324├── build # 默认编译后的文件夹│ ├── static # 静态资源│ ├── index.html │ ├── gui.js │ ├── lib.js # 编译后主要的js文件 ├── src│ ├── components # UI组件，负责页面呈现│ ├── containers # 容器组件，承载容器组件业务逻辑│ ├── css # 全局通用css│ ├── examples # 集成测试用例│ ├── extensions # 拓展案例│ ├── lib # 插件及高阶组件│ ├── audio # 声音插件│ ├── backpack # 背包插件│ ├── default-project # 默认项目│ ├── libraries # 素材库相关│ ├── video # 视频模块│ ├── playground # 编译后页面的模版│ ├── reducers # 全局状态控制├── test # 测试用例├── translations # 翻译库├── README.md└── package.json└── webpack.consig.js 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]},{"title":"Scratch3.0——作品截图","slug":"scratch-Scratch3-0——作品截图","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T08:56:35.339Z","comments":true,"path":"scratch-Scratch3-0——作品截图/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——作品截图/","excerpt":"","text":"Scratch 的舞台是基于canvas，最初尝试直接通过canvas的dom，然后生成图片，但最后只能得到一个黑色的图片，得到黑色图片的原因是没有取到有效的canvas而不是因为图片跨域，当初在这里走了很多弯路，继续研究舞台组件stage.jsx，从vm.renderer可以获取canvas，于是通过这个canvas对象生成图片，记得当时的效果是偶尔会得到有效图片，但是大部分时候依然是黑色的图片，原因稍后回解释。为了实现截图，当时又进一步研究了renderer的代码，最后找到了draw方法，通过多次尝试发现在draw方法的最后执行canvas对象生成图片可以获得舞台的有效图片。 最初的笨办法在node_modules中找到scratch-render/src/RenderWebGL.js中的draw方法，也可以直接在dist中修改编译后的文件。顺便解释一下draw是对舞台进行了清理和重新绘制，而draw的频率非常频繁，因此不能直接通过canvas获取图片。在重绘后追加获取图片的toDataURL方法，考虑到需要在gui里面调用，此处采用了监听键盘事件来通信，接收到截图请求将舞台图片放在window.sessionStorage内存中，在需要使用的时候可以直接从sessionStorage获得。123456789101112131415161718192021draw () &#123; this._doExitDrawRegion(); // 获取gl const gl = this._gl; // twgl.bindFramebufferInfo(gl, null); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); gl.clearColor.apply(gl, this._backgroundColor); gl.clear(gl.COLOR_BUFFER_BIT); // 重新绘制 this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection); // 增加如下代码 let img = new Image(); img.src = gl.canvas.toDataURL('image/png',0.7) document.onkeydown = function (e) &#123; if(e.keyCode == 16)&#123; window.sessionStorage.setItem(\"coverImg\",img.src) console.log('webGL') &#125; &#125; &#125; 带来问题 直接修改node_modules依赖的内容，严重影响团队开发、项目部署，提升了项目维护的复杂度。 每次draw都会执行toDataURL方法，并且赋值，增大了系统开销。 通过事件映射，提升了项目的复杂度。 优化回归最初问题的本源，不能直接从canvas.toDataURL获得舞台截图的原因是执行toDataURL的时候可能正好draw在重绘。因此先截图前先draw然后获取图片。123this.renderer.draw();const img = new Image();img.src = this.canvas.toDataURL('image/png', 0.7); 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]},{"title":"Scratch3.0——克隆代码仓库的正确姿势","slug":"scratch-Scratch3-0——克隆代码仓库的正确姿势","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T09:02:09.586Z","comments":true,"path":"scratch-Scratch3-0——克隆代码仓库的正确姿势/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——克隆代码仓库的正确姿势/","excerpt":"","text":"对Scratch3.0进行二次开发，首先要在github上fock官方代码，但是在自己开发的同时又要跟进官方的代码就要在git做如下配置。 步骤：1、配置上游项目地址。即将你 fork 的项目的地址给配置到自己的项目上。使用以下命令来配置。1➜ git remote add upstream https://github.com/LLK/scratch-gui.git 然后可以查看一下配置状况，很好，上游项目的地址已经被加进来了。12345➜ git remote -vorigin https://github.com/***/scratch-gui.git (fetch)origin https://github.com/***/scratch-gui.git (push)upstream https://github.com/LLK/scratch-gui.git (fetch)upstream https://github.com/LLK/scratch-gui.git (push) 2、获取上游(官方)项目更新。使用 fetch 命令更新，fetch 后会被存储在一个本地分支 upstream/master 上。如果长时间没有更新，可能会非常慢，一定要在网络环境好的情况下更新或从GitHub下载代码。1➜ git fetch upstream 3、合并到本地分支。切换到 master 分支，合并 upstream/master 分支。1➜ git merge upstream/master 如果提示： fatal: refusing to merge unrelated histories，这是因为本地和远端已经是两个独立的版本库，git认为是不相干的版本库。1➜ git merge upstream/master --allow-unrelated-histories 4、合并冲突。因为是在原先代码的基础上二次开发，冲突不可避免，而最费时间的也是这里解决冲突这一步。 5、提交推送。根据自己情况提交推送自己项目的代码。1➜ git push origin master 由于项目已经配置了上游项目的地址，所以如果 fork 的项目再次更新，重复步骤 2、3、4即可。 留几个问题供大家思考交流： 冲突在所难免，在开发中注意什么可以更快更高效的解决冲突合并代码？ 如果官方代码重构了某部分模块，你的代码严重依赖该模块该如何处理？ 如果需要修改开源系统，不要改动原系统，而是要开发辅助系统。（——从零开始学架构） 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]}]}