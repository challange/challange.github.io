{"meta":{"title":"高家祺的博客","subtitle":null,"description":null,"author":"高家祺","url":"https://challange.github.io","root":"/"},"pages":[{"title":"我的架构师之路——书单","date":"2019-04-13T03:37:59.732Z","updated":"2019-04-13T03:37:59.731Z","comments":true,"path":"books/index.html","permalink":"https://challange.github.io/books/index.html","excerpt":"","text":"计算机系统 深入理解计算机系统 深入理解并行编程 深入理解LINUX内核 编码，隐匿在计算机背后的语言 JAVA 码出高效Java开发手册——杨冠宝（孤尽）、高海慧（鸣莎） Mybatis从入门到精通——刘增辉 JAVA性能权威指南——Scott Oaks Java工程师修炼之道 深入理解JVM &amp; G1 GC——周明耀 Java架构师指南 Java微服务 数据结构与算法Java语言描述——Allen B.Downey 图解Java多线程设计模式——结城浩 Effective Java中文版 Spring 5 高级编程 Spring技术内幕——计文柯 Spring源码深度解析——郝佳 SpringCloud微服务实战——翟永超 深入理解SpringCloud与微服务构建——方志明 SpringBoot实战，JavaEE开发的颠覆者 深入实践SpringBoot Kafka权威指南——薛命灯 Elasticsearch源码解析与优化实战——张超 Java核心技术卷1+卷2 Java编程思想(第4版) Java8实战 Java编程的逻辑 Java并发编程的艺术 Java程序员修炼之道 Java常用算法手册 深入理解 Java 虚拟机 架构 图解性能优化 架构探险，从零开始写Java Web框架——黄勇 架构探险，轻量级微服务架构（上）——黄勇 架构探险，轻量级微服务架构（下）——黄勇 架构整洁之道——Martin，孙宇聪 大道至简——软件工程实践者的思想——周爱民 Tomcat架构解析——刘光瑞 Head First 设计模式 分布式服务架构：原理、设计与实践 人人都是架构上：分布式系统架构落地与瓶颈突破 代码整洁之道 Tomcat内核设计剖析——汪建 Head First 软件开发 从零开始学架构——李运华 软件是这样“炼“成的——从软件需求分析到软件架构设计 可伸缩服务架构：框架与中间件 大型分布式网站架构设计与实践 架构即是未来，现代企业可拓展的Web架构、流程和组织 恰如其分的软件架构 设计模式的艺术，软件开发人员内功修炼之道 系统机构，复杂系统的产品设计与开发 分布式服务框架原理与实战 重构，改善既有代码设计 数据库 Redis深度历险，核心原理与应用实践——钱文品 Sql必知必会 SQL优化核心思想 数据建模经典教程 高性能Mysql(第三版) 高性能SQL，调优精要与案例解析——闫书清 SQL学习指南 Neo4j实战 Neo4j全栈开发 图数据库 MongoDB应用设计模式 Mysql排错指南 前端 前端工程化体系设计与实践 前端架构设计 React设计模式与最佳实践——林昊 React状态管理与同构实战——侯策、颜海镜 React进阶之路 新时期的Nodejs入门 Nodejs实战 CSS世界 React学习手册 高效前端：Web高效编程与优化实践 编写可维护的JavaScript Web前端技术 Nodejs与express开发 产品 自传播：为产品注入自发传播的基因 启示录：打造用户喜爱的产品 产品设计与开发 用户故事地图 用户体验可视化指南 用户体验要素——用户为中心的产品设计 其他 C Primer Plus(第五版) 算法图解 CTO说 剑指Offer 编程珠玑 GO语言编程 GO语言学习笔记 逆流而上，阿里巴巴技术成长之路 技术之瞳，阿里巴巴技术笔试心得 明解C语言，入门篇 明解JAVA 像科学家一样思考Python 笨办法学Python Activiti实战 Activiti权威指南 工作流管理-模型、方法和系统 疯狂Workflow讲义，机遇Activiti的工作流应用开发 马云正传，活着就是为了颠覆世界 图解机器学习 图解深度学习 代码之髓 极简人工智能，你一定爱读的AI通识书 区块链技术指南 NodeJs区块链开发 Linux入门很简单 C++面向对象程序设计 Linux入门很简单 Arduino实战指南 Arduino实战案例 Arduino软硬件协同设计实战指南 美团机器学习实战 机器学习实战 机器学习系统设计 科学前沿图谱，知识可视化探索"},{"title":"分类","date":"2019-04-07T07:11:25.010Z","updated":"2019-04-07T05:50:28.000Z","comments":false,"path":"categories/index.html","permalink":"https://challange.github.io/categories/index.html","excerpt":"","text":""},{"title":"资料链接","date":"2019-04-07T07:15:22.545Z","updated":"2019-04-07T07:15:22.543Z","comments":true,"path":"links/index.html","permalink":"https://challange.github.io/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-04-07T07:13:22.859Z","updated":"2019-04-07T05:50:28.000Z","comments":false,"path":"repository/index.html","permalink":"https://challange.github.io/repository/index.html","excerpt":"","text":""},{"title":"错误信息整理","date":"2019-04-07T13:00:38.000Z","updated":"2019-05-05T08:12:33.813Z","comments":true,"path":"problem/index.html","permalink":"https://challange.github.io/problem/index.html","excerpt":"","text":"SpringCloud 1Consider defining a bean of type &apos;org.springframework.http.codec.ServerCodecConfigurer&apos; in your configuration. spring-boot-starter-web与spring-cloud-starter-gateway存在jar包冲突Spring Cloud Gateway 是使用 netty+webflux 实现因此不需要再引入 web 模块。 Spring Cloud Gateway 项目会吞异常日志，需要找到原因 数据库相关 mysql排序稳定性问题 12Cause: java.sql.SQLException: Zero date value prohibitedcom.mysql.cj.core.exceptions.DataReadException: Zero date value prohibited 数据时区错误，由于数据库字段timestamp类型有时间0000-00-00 00:00:00，修改为正常时间即可。timestamp的默认值：CURRENT_TIMESTAMP（插入时个更新时间）、ON UPDATE CURRENT_TIMESTAMP（仅在更新时设置时间，插入时赋值）、CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP （创建和修改时都修改此值） 压测相关1Cause: java.net.NoRouteToHostException: Cannot assign requested address. 系统的连接端口耗尽 前端相关 Http ResponseHeader 中的自定义属性，如果浏览器请求抓包可以看到，但是js中获取不到，则需要检查跨域配置 解决： 响应头Access-Control-Expose-Headers，配置自定义属性，然后就可以获取到了。 问题请求：angular1.6 $http.post原文：http://www.it1352.com/886056.html参考：跨域资源共享 CORS 详解 在react中，setState是异步操作，赋值后不能马上生效。 1The value of the &apos;Access-Control-Allow-Origin&apos; header in the response must not be the wildcard &apos;*&apos; when the request&apos;s credentials mode is &apos;include&apos;. 当看到此错误时注意，当前端请求配置credentials: “include”时，后端需要配置”Access-Control-Allow-Credentials”为true，这样才能使带credentials的CORS请求成功。SpringBoot2.0下对跨域的处理方式可以为使用@CrossOrigin注解或者编写配置类实现WebMvcConfigurer接口的addCorsMappings方法。 12345678@Overridepublic void addCorsMappings(CorsRegistry registry) &#123; registry.addMapping(&quot;/**&quot;) .allowedHeaders(&quot;*&quot;) .allowedMethods(&quot;POST&quot;,&quot;GET&quot;) .allowedOrigins(&quot;*&quot;) .allowCredentials(true);&#125; React Eslint 报错与警告Do not use setState in componentDidMountcomponentDidMount 执行是在DOM渲染完成后，在这里面使用setState会触发重绘，相当于进行了两次渲染，因此建议在constructor或者componentWillMount中把准备工作做好。当然在componentDidMount 周期异步获取数据并通过setState赋值是正确逻辑。 Arrow function should not return assignment.12case：&lt;div ref=&#123;(el) =&gt; &#123; this.myCustomEl = el &#125;&#125; /&gt; 在使用箭头函数的时候，不应当返回赋值语句。 JSX props should not use arrow functionsA bind call or arrow function in a JSX prop will create a brand new function on every single render. This is bad for performance, as it may cause unnecessary re-renders if a brand new function is passed as a prop to a component that uses reference equality check on the prop to determine if it should update.https://github.com/yannickcr/eslint-plugin-react/blob/master/docs/rules/jsx-no-bind.md Expected to return a value in arrow function array-callback-return Linux及生产环境问题磁盘没有空间：Error: ENOSPC: no space left on device, write解决方案：增大磁盘空间或删除迁移没用文件，如日志文件"}],"posts":[{"title":"云原生时代下的12-Factor应用原则","slug":"微服务-云原生时代下的12-Factor应用原则","date":"2019-05-06T08:05:05.000Z","updated":"2019-05-08T16:30:42.471Z","comments":true,"path":"微服务-云原生时代下的12-Factor应用原则/","link":"","permalink":"https://challange.github.io/微服务-云原生时代下的12-Factor应用原则/","excerpt":"","text":"使用标准化流程自动配置，从而使新的开发者花费最少的学习成本加入这个项目。 和操作系统之间尽可能的划清界限，在各个系统中提供最大的可移植性。 适合部署在现代的云计算平台，从而在服务器和系统管理方面节省资源。 将开发环境和生产环境的差异降至最低，并使用持续交付实施敏捷开发。 易拓展：可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。 I. 基准代码——一份基准代码（Codebase），多份部署（deploy）12-Factor应用通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 代码库（code repository, code repo, repo）。在类似 SVN 这样的集中式版本控制系统中，基准代码 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，基准代码 则是指最上游的那份代码库。 一份代码库对应多份部署 基准代码和应用之间总是保持一一对应的关系： 一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码拆分为独立的类库，然后使用 依赖管理 策略去加载它们（然而多个应用共享一份基准代码缺在很多公司很常见，特别在Two B的公司，很多公司会有定制需求）。尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 部署 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。· 所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。 II. 依赖——显式声明依赖关系（ dependency ）大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。 12-Factor规则下的应用程序不会隐式依赖系统级的类库。 它一定通过 依赖清单 ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。 例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。 显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。 12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。 III. 配置——在环境中存储配置通常，应用的 配置 在不同 部署 (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括： 数据库，Memcached，以及其他 后端服务 的配置 第三方服务的证书，如 Amazon S3、Twitter 等 每份部署特有的配置，如域名等 有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。 判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。 需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。 另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。 12-Factor推荐将应用的配置存储于 环境变量 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。 配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。 12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。 IV. 后端服务——把后端服务当作附加资源(backing services)后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。 类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。 12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 配置 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。 每个不同的后端服务是一份 资源 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。 一种部署附加4个后端服务 部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。 V. 构建，发布，运行——严格分离构建和运行基准代码 转化为一份部署(非开发环境)需要以下三个阶段： 构建阶段 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。 发布阶段 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。 运行阶段 （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。代码被构建，然后和配置结合成为发布版本 12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。 部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。 每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。 新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。 VI. 进程——以一个或多个无状态进程运行应用运行环境中，应用程序通常是以一个和多个 进程 运行的。 最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。 12-Factor 应用的进程必须无状态且无共享 。 任何需要持久化的数据都要存储在 后端服务 内，比如数据库。 内存区域或磁盘空间可以作为进程在做某种事务型操作时的缓存，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。 源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作——正如 Rails资源管道 ，而不是在运行阶段。 一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。 VII. 端口绑定——通过端口绑定提供服务互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。 12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。 本地环境中，开发人员通过类似 http://localhost:5000/ 的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。 通常的实现思路是，将网络服务器类库通过 依赖声明 载入应用。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。 HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。 还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。 VIII. 并发——通过进程模型进行扩展任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。 扩展表现为运行中的进程，工作多样性表现为进程类型。 在 12-factor 应用中，进程是一等公民。12-Factor 应用的进程主要借鉴于 unix 守护进程模型 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。 这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。 上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。 12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。 IX. 易处理——快速启动和优雅终止可最大化健壮性12-Factor 应用的 进程 是 易处理（disposable）的，意思是说它们可以瞬间开启或停止。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。 进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。 进程 一旦接收 终止信号（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。 对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。 进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。 X. 开发环境与线上环境等价——尽可能的保持开发，预发布，线上环境相同从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面： 时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。 人员差异： 开发人员编写代码，运维人员部署代码。 工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。12-Factor 应用想要做到 持续部署 就必须缩小本地与线上差异。 再回头看上面所描述的三个差异: 缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。 缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。 缩小工具差异：尽量保证开发环境以及线上环境的一致性。将上述总结变为一个表格如下： Item 传统应用 12-Factor 应用 每次部署间隔 数周 几个小时 开发人员 vs 运维人员 不同的人 相同的人 开发环境 vs 线上环境 不同 尽量接近 后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。 类型 语言 类库 适配器 数据库 Ruby/Rails ActiveRecord MySQL, PostgreSQL, SQLite 队列 Python/Django Celery RabbitMQ, Beanstalkd, Redis 缓存 Ruby/Rails ActiveSupport::Cache Memory, filesystem,Memcached 开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。 12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。 与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。 不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。 XI. 日志——把日志当作事件流日志 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。 日志应该是 事件流 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。 12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。 在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。 这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括： 找出过去一段时间特殊的事件。 图形化一个大规模的趋势，比如每分钟的请求量。 根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。 XII. 管理进程——后台管理任务当作一次性进程运行进程构成（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如： 运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。 运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。 运行一些提交到代码仓库的一次性脚本。 一次性管理进程应该和正常的 常驻进程 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 发布版本 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。 所有进程类型应该使用同样的 依赖隔离 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。 12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。","categories":[{"name":"微服务","slug":"微服务","permalink":"https://challange.github.io/categories/微服务/"}],"tags":[{"name":"微服务","slug":"微服务","permalink":"https://challange.github.io/tags/微服务/"}]},{"title":"Git操作整理","slug":"Git-GIt操作整理","date":"2019-05-06T08:05:05.000Z","updated":"2019-05-08T16:24:18.164Z","comments":true,"path":"Git-GIt操作整理/","link":"","permalink":"https://challange.github.io/Git-GIt操作整理/","excerpt":"","text":"基础操作查看全局配置信息1git config --list 设置全局配置信息1git config --global user.name &quot;wwyz&quot; 初始化本地仓库1git init 将文件加入git版本库1git add &quot;文件名&quot; 拉取代码1git clone &quot;版本库地址&quot; &quot;目录名&quot; 查看文件状态1git status 提交代码12git commit &quot;说明&quot;git commit --amend # 重新提交 移除文件,移除后文件不在被版本控制12git rmgit rm --cached readme.txt #缓存中移除 移动文件1git mv &quot;文件路径&quot; &quot;目标文件路径&quot; 查看提交文件历史12git loggit log -p -2 #-p选项展开显示每次提交的内容差异，用-2则仅显示最近的两次更新 查看远程仓库1234567git remote -v# 添加远程仓库git remote add pb git://github.com/paulboone/ticgit.git# 拉取远程代码更新git fetch pb# 查看远程仓库的信息git remote show origin 推送提交的代码1git push origin master 忽略文件 通过在项目根目录配置.gitignore文件忽略要忽略的文件/文件夹。Java项目一般忽略：.idea、target、out、classes前端项目一般忽略：.idea、node_modules、dist .gitignore 格式规范如下： 所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。 可以使用标准的 glob(shell 所使用的简化了的正则表达式)模式匹配。 匹配模式最后跟反斜杠（/）说明要忽略的是目录。 要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。 12*.[oa] # 忽略所有以 .o 或 .a 结尾的文件*~ # 忽略所有以波浪符（~）结尾的文件 Tag打标签 对某一时间点上的版本打上标签，通常结合版本使用。Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。 列出已有标签1git tag 分支 使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。 什么是分支 在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。 新建分支1git branch &quot;分支名&quot; 切换分支1git checkout &quot;分支名&quot; 合并分支12# 将其他分支合并到本分支git merge &quot;分支名&quot; 分支变基12345git rebase# 将多次提交合并为一次提交，-i表示弹出交互式的界面让用户编辑完成合并操作git rebase -i &quot;开始提交点&quot; &quot;结束提交点&quot;# 将某一段commit粘贴到另一个分支上git rebase &quot;开始提交点&quot; &quot;结束提交点&quot; --onto &quot;分支名称&quot; Git官方文档Git教程-廖雪峰","categories":[{"name":"Git","slug":"Git","permalink":"https://challange.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://challange.github.io/tags/Git/"}]},{"title":"Java基础学习——泛型","slug":"DIY-DIY——泛型","date":"2019-05-06T08:05:05.000Z","updated":"2019-05-08T16:13:41.420Z","comments":true,"path":"DIY-DIY——泛型/","link":"","permalink":"https://challange.github.io/DIY-DIY——泛型/","excerpt":"","text":"1. Java如果没有泛型会有什么灾难？泛型是参数化类型，在使用时告诉编辑器使用什么类型。 程序可控性：泛型有限定类型，泛型可以使程序执行时的类型是确定的，避免了程序的不可控性。在泛型引入之前，对于不确定类型需要使用Object，然后类型强转，此处带来的问题，Object含义不清，使代码不易懂，同时类型无界限限定，很可能会想当然使用错误类型。泛型的引入，在开发是对类或者方法的范围做一个限定，使类和方法运行在有限的类型中，使程序更清晰，可控性更强 上图是ArrayList的add操作，jdk1.5前参数为Object，也就意味着任何类型都可以放入list中。 提升复用性：解耦类或方法对类型之间的约束，通过参数化类型，使执行相同功能的方法、类能够复用代码，如果没有泛型，相同的代码每个类都要写一份，带来了大量冗余代码。一个场景，CRUD在web项目广泛使用，逻辑类似，每个类型写一遍crud方法就会造成很多冗余代码，这时可以封装一个泛型基类，一份代码给所有类型用。 使用泛型，编译时就能确保容器中插入对象的类型安全，编译器发现问题要好于运行时发现问题，运行时出问题很有可能就意味着生产事故了。我们应该避免产生隐藏较深的bug，让bug越早暴露越好。2. List&lt;? extends T&gt;和List&lt;? super T&gt;有哪些区别？ List&lt;? extends T&gt;，Get Frist适用于消费集合为主的场景，List&lt;? extends T&gt;可以赋值给任何T及T子类的场景，上界为T，put受限，add只能放入null，不能放入其他元素;使用List&lt;? extends T&gt;相当于一个视图，不具有修改能力，但被赋值的原集合修改，视图可以感知。 List&lt;? super T&gt;，Put Frist适用于生产集合为主的场景，List&lt;? super T&gt;可以赋值给任何T及T的父类集合，下界为T，put可以放入T及T的父类类型，get受限，get可以使用，但是类型会被擦除到Object。 不同点维度:赋值，put、get List&lt;? extends T&gt;类比于数据库的视图，T决定了结果集列的属性，相同与视图的List&lt;? extends T&gt;也是主要用于展示，如果要添加或者删除记录，则应修改原先的list。 3. 类名&lt;? super T&gt;存在哪些实际应用场景？（参考Comparator）Comparator&lt;? super T&gt; 准许为所有的子类使用相同的比较器。通常我们会使用Comparator自己定义对象的比较规则，如果要比较猫的重量，那么就实现猫重量的比较器，比较狗的重量，则需要实现狗重量的比较器，但如果要允许将猫与狗的重量进行比较，则就需要Comparator&lt;? super T&gt;来发挥作用，定义animal的比较器，就可以比较猫和狗的重量。&lt;? super T&gt;使的方法可以使方法不仅可以作用于父类也可以作用于子类，增加了代码的复用性。 补充泛型会擦除传入实体的属性，如果使用&lt; T &gt;，则T的类型在代码执行时会被擦除，因为Object是所有类的父类，所以此时T只具有Object的属性，但是当使用&lt; ? super T&gt;或&lt;? extends T&gt; ,定义边界，T的类型会被保留到边界T。 泛型在Java1.5引入，在泛型引入前java语言已经有了广泛的发展，较好的生态，拥有大量的类库，因此java在引入泛型的同时，也考虑到了兼容过去代码（java升级良好的兼容性我想是java能够经久不衰的重要原因）。java的泛型是具有类型擦除特性的泛型具有类型推断能力，但是类型推断仅在赋值时有效。如果将泛型方法返回结果作为参数，这时并不会执行类型推断。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://challange.github.io/categories/Java基础/"}],"tags":[{"name":"DIY","slug":"DIY","permalink":"https://challange.github.io/tags/DIY/"},{"name":"Java基础","slug":"Java基础","permalink":"https://challange.github.io/tags/Java基础/"},{"name":"泛型","slug":"泛型","permalink":"https://challange.github.io/tags/泛型/"}]},{"title":"Java基础学习——Lambda表达式","slug":"DIY-DIY——Lambda表达式","date":"2019-05-06T08:05:05.000Z","updated":"2019-05-08T16:09:30.086Z","comments":true,"path":"DIY-DIY——Lambda表达式/","link":"","permalink":"https://challange.github.io/DIY-DIY——Lambda表达式/","excerpt":"","text":"函数式编程是什么 函数式编程，是一种使用函数进行编程的方式，一个“函数”对应于一个数学函数:它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用，函数式函数无论在何处、何时、何地对于同样的输入总会返回相同的结果。 一、函数式编程优劣势对比匿名类与Lambda表达式代码简洁，相较于匿名内部类，Lambda表达式大大简化了代码量,代码可读性也会更好123456Runnable r1 = new Runnable()&#123; public void run()&#123; System.out.println(\"Hello\"); &#125;&#125;Runnable r2 = () -&gt; System.out.println(\"hello\"); 局限： 匿名类与lambda表达式中的this和super含义是不同的，在匿名类中，this代表自身，而lambda代表的是包含类。 匿名类可以屏蔽包含类的变量，而lambda不能，但是与包含类使用相同的变量，变量就容易产生歧义，难于理解。 123456int a = 10;Runnable r1 = () -&gt; &#123;// int a = 10; // 编译错误 int a1 = 10; System.out.println(a1);&#125;; 在涉及重载的方法，Lambda表达式可能会导致模棱两可，但可以通过强制类型转换来解决。 1234567891011121314151617interface Task &#123; public void execute();&#125; public static void doSomething(Runnable r)&#123; r.run();&#125;;public static void doSomething(Task r)&#123; r.execute();&#125;;public static void main(String[] args) &#123; // Error:(19, 9) java: 对doSomething的引用不明确 // doSomething(() -&gt; System.out.println(\"1234\")); doSomething((Task) () -&gt; System.out.println(\"1234\")); &#125; 行为参数化Lambda表达式引入了将方法作为参数传递的能力，在环绕场景下（一个方法只有中间部分逻辑不一样），增加了方法的复用，减少代码冗余。结合泛型理解，泛型使类或方法可以复用于更多的变量类型， 而函数式则进一步拓展了方法的复用性。局限： 提供行为参数化后，如果行为较为复杂，则很难一眼看出行为的含义，这时候就会降低代码的可读性，相较而言，命名规范的函数则有见名知意的好处。 无副作用纯函数，引用透明所谓共享数据就是数据可能被多个方法读取更新，在并发使用数据的时候必须通过上锁来确保线程安全。函数式编程所倡导的避免共享可变数据，只要参数确定就一定会返回确定结果，增加程序的可控性，不用考虑复杂易错的锁机制，使并行更加容易，充分利用计算机多核优势。 为了维持不可变性，“函数式”的函数或者方法都只能修改本地变量，并且它引用的对象都应是不可变对象.。 局限： 为了确保避免共享可变数据引入——增加定义变量与赋值——增大了空间的使用 异常函数式要求函数或者方法不应抛出任何异常，因为一旦抛出异常，结果就被终止了；类比于数学函数，传入一个合法的参数，一定会返回一个确定的结果。在不使用异常的情况下，Java8引入了Optional&lt; T&gt;类型来承载异常情况，如果异常不能返回结果则返回一个空的optional对象。 声明式编程经典的面向对象编程我们专注于如何实现，思维模式为：“首先做这个，紧接着更新那个，然后……”，面向对象是抽象对象、对象之间的交互；而函数式编程更关注与要做什么，Stream流是典型的应用，采用这种“要做什么”风格的编程就是声明式编程，编程者考虑的是指定规则，而由系统或者封装来觉得如何实现这个目标。这样带来的好处是让代码更加接近于问题陈述。 习惯于声明式编程思维，我们可以更容易的利用化归思想，将复杂问题拆分为若干小问题逐步解决，自顶向下，开始更加关注于函数的输入以及输出结果，而不是过早的考虑如何做、修改哪些东西。 高阶函数与科里化满足接受一个或多个函数作为参数或返回结果是一个函数的函数都是高阶函数，高阶函数提供了链式调用的功能。 科里化是一种将具备2个参数（比如，x和y）的函数f转化为使用一个参数的函数g，并且这个函数的返回值也是一个函数，它可以作为新的函数的一个参数。后者返回值与初始函数返回值，f(x,y)=(g(x))y 高阶函数与科里化也使声明式编程可以更加运用自如。 延迟计算与惰性求值延迟计算以Stream为例，向Stream发起的一系列中间操作会先被一一保存起来，直到发起一个终端操作（Stream分为中间操作和中端操作，中间操作返回一个Stream，终端操作从流水线生成结果），才会进行实际的计算。延迟计算与惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序:抵消相同项从而避免执行无谓的代码，优化代码的执行顺序从而实现更高的执行效率甚至是减少错误。局限 惰性求值最大的问题还是惰性，现实世界中很多问题还是需要严格求值的，需要严格的顺序执行，如System.nextLine()每次会读取下一行记录 测试与调试 许多同学提到函数式程序难调试，个人觉得并不是因为难调试，而是我们要掌握调试的方法和工具 单元测试：因为函数式程序无副作用的特性使得单元测试更加容易，唯一需要做的就是传递一些可以代表边界条件的参数给这些函数并返回确定的结果，并且不会受其他因素干扰，如调用顺序、外部状态干扰等。Lambda没有函数名，的确带来了测试困难，这时可以借助某个字段访问Lambda函数来测试函数内封装的逻辑，可能又会问每个表达式定义一个变量做测试也太麻烦了，从声明式编程的角度出发，我们应该关注的是一个方法的可靠性，每个lambda仅仅是函数的实现细节，当放在函数内整体测试。 Java Stream Debugger工欲善其事必先利其器，推荐个调试插件Java Stream Debugger，可以以可视化的形式展现stream筛选过滤的过程。 日志输出使用peek方法可以在stream输Alt text出当前执行的元素，便于判断问题。1234567List&lt;People&gt; list = peopleList.stream() .peek(x -&gt; System.out.println(\"frist:\"+x)) .filter(item -&gt; item != null) .peek(x -&gt; System.out.println(\"second:\"+x)) .filter(item -&gt; item.getAge() &gt; 5) .peek(x -&gt; System.out.println(\"three:\"+x)) .collect(Collectors.toList()); 性能 在Java7引入了InvokeDynamic指令，用于支持在JVM上运行动态类型语言，Lambda表达式使用InvokeDynamic指令使表达式转化为字节码推迟到了运行时，避免了静态初始化，生成大量的匿名类，由此带来的问题，函数首次运行需要先进行编译，也就造成首次运行可能会占用较长时间，因此需要注意预热。 包装类型转换往往不易发现，需要重点关注 总的来说lambda不会对程序性能带来提升，甚至有可能性能下降，但是我们还是得拥抱它，因为它在多核并行计算、代码可读性、可拓展行上的优势足以抵消它降低的性能。 其他问题： 增加了使用门槛，但是工欲善其事必先利其器，作为一个合格Java程序猿本身就应具备持续的学习能力 二、Stream流的哪一个方法最有价值，为什么？ 同学们为自己心目中最有价值的Stream流方法进行了投票，投票结果来看最受欢迎的三个方法是filter、map、collect，filter主要因为可以进行条件过滤，map方法则可以映射每个元素生成新的元素，collect则是最后收集元素必不可少的一环，这三个方法无疑是Stream流操作最常用的方法。 简单讲一下流的定义：从支持数据处理的源生成的元素序列。 元素序列——流提供了可以访问特定元素类型的一组有序值的接口。流的目的在于表达计算，比如前面见到的 filter、sorted和map。 源——流会使用一个提供数据的源，如集合、数组或输入/输出资源。 数据处理操作——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。 流的另外两个特点 流水线——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大的流水线。流水线背后其实是一种建造者模式 内部迭代——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。 流的使用一般包括三件事: 一个数据源(如集合)来执行一个查询; 一个中间操作链，形成一条流的流水线; 一个终端操作，执行流水线，并能生成结果。 parallelStream与parallel区别：parallelStream是Collection接口定义的方法，在stream构造时传入参数使用parallel生成并行流。parallel是BaseStream的一个方法，能够将一个顺序流转化为一个并行流，因此在执行parallel前可以以顺序流先进行预处理。如：123456public static long parallelSum(long n) &#123; return Stream.iterate(1L, i -&gt; i + 1) .limit(n) .parallel() // 转化为并行流 .reduce(0L, Long::sum);&#125; Stream流方法的使用 参考文章：傻瓜函数式编程","categories":[{"name":"Java基础","slug":"Java基础","permalink":"https://challange.github.io/categories/Java基础/"}],"tags":[{"name":"DIY","slug":"DIY","permalink":"https://challange.github.io/tags/DIY/"},{"name":"Lambda表达式","slug":"Lambda表达式","permalink":"https://challange.github.io/tags/Lambda表达式/"},{"name":"Java基础","slug":"Java基础","permalink":"https://challange.github.io/tags/Java基础/"}]},{"title":"SpringCloud——Gateway跨域配置","slug":"springcloud-SpringCloud——Gateway跨域配置","date":"2019-05-05T08:05:05.000Z","updated":"2019-05-05T08:15:10.444Z","comments":true,"path":"springcloud-SpringCloud——Gateway跨域配置/","link":"","permalink":"https://challange.github.io/springcloud-SpringCloud——Gateway跨域配置/","excerpt":"","text":"正确配置方法1234567891011121314151617181920/** * 配置跨域 * @return */@Beanpublic CorsWebFilter corsFilter() &#123; CorsConfiguration config = new CorsConfiguration(); // cookie跨域 config.setAllowCredentials(Boolean.TRUE); config.addAllowedMethod(\"*\"); config.addAllowedOrigin(\"*\"); config.addAllowedHeader(\"*\"); // 配置前端js允许访问的自定义响应头 config.addExposedHeader(\"setToken\"); UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource(new PathPatternParser()); source.registerCorsConfiguration(\"/**\", config); return new CorsWebFilter(source);&#125; 配置不生效方法 官方推荐配置 自定义实现GlobalFilter无效","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"SpringCloud——Gateway配置大全","slug":"springcloud-SpringCloud——Gateway配置大全","date":"2019-04-07T08:36:59.000Z","updated":"2019-04-07T08:44:25.545Z","comments":true,"path":"springcloud-SpringCloud——Gateway配置大全/","link":"","permalink":"https://challange.github.io/springcloud-SpringCloud——Gateway配置大全/","excerpt":"","text":"了解Gateway的配置才可以理解使用Gateway可以做什么事情，才能更好地应用在产品开发中。 Predicates Predicates主要起的作用是：配置路由匹配请求的规则 Http相关Path 配置对于请求路径的匹配规则 yml配置，多个参数用逗号隔开 1- Path = /aa/**,/bb/** json配置 1&#123;\"name\":\"Path\",\"args\":&#123;\"pattern\":\"/aa/**\",\"pattern1\":\"/bb/**\"&#125;&#125; Cookie 配置对Cookie中值的匹配，第一个为key，第二个为value。下例匹配cookie设置chocolate:ch.p的请求 yml配置 1- Cookie = chocolate,ch.p json配置 1&#123;\"name\":\"Cookie\",\"args\":&#123;\"_genkey_0\":\"chocolate\",\"_genkey_1\":\"ch.p\"&#125;&#125; Header 匹配Http请求中设置的内容，http-header设置X-Request-Id:\\d+可以匹配，第二个参数第二个参数是正则表达式 yml配置 1- Header = X-Request-Id,\\d+ json配置 1&#123;\"name\":\"Header\",\"args\":&#123;\"_genkey_0\":\"X-Request-Id\",\"_genkey_1\":\"\\d+\"&#125;&#125; Host 匹配Http请求Host，匹配所有host为**.somehost.com的请求 yml配置 1- Host = **.somehost.com json配置 1&#123;\"name\":\"Host\",\"args\":&#123;\"_genkey_0\":\"**.somehost.com\"&#125;&#125; Method 匹配Http请求头 yml配置 1- Method = GET json配置 1&#123;\"name\":\"Method\",\"args\":&#123;\"_genkey_0\":\"GET\"&#125;&#125; Query 匹配Http请求中的查询参数，请求中携带param1=value的请求可以匹配 yml配置 1- Query = param1,value json配置 1&#123;\"name\":\"Query\",\"args\":&#123;\"_genkey_0\":\"param1\",\"_genkey_1\":\"value\"&#125;&#125; RemoteAddr 匹配请求中的RemoteAddr yml配置 1- RemoteAddr = 192.168.1.1/24 json配置 1&#123;\"name\":\"RemoteAddr\",\"args\":&#123;\"_genkey_0\":\"192.168.1.1/24\"&#125;&#125; 时间相关After 设置时间之后可以访问 yml配置 1- After = 2017-01-20T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"After\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"&#125;&#125; Before 设置时间之前可以访问 yml配置 1- Before = 2017-01-20T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"Before\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"&#125;&#125; Before 设置时间段内可以访问 yml配置 1- Between = 2017-01-20T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver] json配置 1&#123;\"name\":\"Between\",\"args\":&#123;\"_genkey_0\":\"2017-01-20T17:42:47.789-07:00[America/Denver]\"，\"_genkey_1\":\"2017-01-21T17:42:47.789-07:00[America/Denver]\"&#125;&#125; 权重路由 至少两组以上路由可以配置权重路由，配置后会根据权重随机访问几个路由 yml配置 1- Weight = service1,80 json配置 1&#123;\"name\":\"Weight\",\"args\":&#123;\"_genkey_0\":\"service1\",\"_genkey_1\":\"80\"&#125;&#125; Filters路径重写 yml配置 1- RewritePath = /path/(?&lt;segment&gt;.*), /$\\&#123;segment&#125; json配置 1&#123;\"name\":\"RewritePath\",\"args\":&#123;\"_genkey_0\":\"/foo/(?&lt;segment&gt;.*)\",\"_genkey_1\":\"/$\\\\&#123;segment&#125;\"&#125;&#125; 修改请求头 yml配置 1- AddRequestHeader = X-Request-Foo,Bar json配置 1&#123;\"name\":\"AddRequestHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 修改请求参数 yml配置 1- AddRequestParameter = foo,bar json配置 1&#123;\"name\":\"AddRequestParameter\",\"args\":&#123;\"_genkey_0\":\"foo\",\"_genkey_1\":\"bar\"&#125;&#125; 修改响应参数 yml配置 1- AddResponseHeader = X-Request-Foo,Bar json配置 1&#123;\"name\":\"AddResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 路径前缀增强 请求路径/hello, 将会被替换为 /mypath/hello yml配置 1- PrefixPath = /mypath json配置 1&#123;\"name\":\"PrefixPath\",\"args\":&#123;\"_genkey_0\":\"/mypath\"&#125;&#125; 路径前缀删除 请求/name/bar/foo，去除掉前面两个前缀之后，最后转发到目标服务的路径为/foo yml配置 1- StripPrefix = 2 json配置 1&#123;\"name\":\"StripPrefix\",\"args\":&#123;\"_genkey_0\":\"2\"&#125;&#125; 请求携带保留原始Host yml配置 1- PreserveHostHeader json配置 1&#123;\"name\":\"PreserveHostHeader\",\"args\":&#123;&#125;&#125; 重定向 yml配置 1- RedirectTo = 302,http://acme.org json配置 1&#123;\"name\":\"RedirectTo\",\"args\":&#123;\"_genkey_0\":\"302\",\"_genkey_1\":\"http://acme.org\"&#125;&#125; 断路器 yml配置 12345- name: Hystrix args: # 断路后跳转地址 name: fallbackcmd fallbackUri: forward:/incaseoffailureusethis json配置 1&#123;\"name\":\"Hystrix\",\"args\":&#123;\"name\":\"fallbackcmd\",\"fallbackUri\":\"forward:/incaseoffailureusethis\"&#125;&#125; 集成Redis原生支持请求限流 yml配置 1234- name: RequestRateLimiter args: redis-rate-limiter.replenishRate: 10 redis-rate-limiter.burstCapacity: 20 json配置 1&#123;\"name\":\"RequestRateLimiter\",\"args\":&#123;\"redis-rate-limiter.replenishRate\":\"10\",\"redis-rate-limiter.burstCapacity\":\"20\"&#125;&#125; 删除请求头属性 yml配置 1- RemoveRequestHeader = X-Request-Foo json配置 1&#123;\"name\":\"RemoveRequestHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\"&#125;&#125; 删除响应头属性 yml配置 1- RemoveResponseHeader = X-Request-Foo json配置 1&#123;\"name\":\"RemoveResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Request-Foo\"&#125;&#125; 重写响应头 将请求 /42?user=ford&amp;password=omg!what&amp;flag=true, 改为 /42?user=ford&amp;password=***&amp;flag=true yml配置 1- RewriteResponseHeader = X-Response-Foo,password=[^&amp;]+,password=*** json配置 1&#123;\"name\":\"RewriteResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Response-Foo\",\"_genkey_1\":\"password=[^&amp;]+\",\"_genkey_2\":\"password=***\"&#125;&#125; 重设请求路径 请求/foo/bar，在接下来的处理中被改为/bar yml配置 1- SetPath =/&#123;segment&#125; json配置 1&#123;\"name\":\"SetPath\",\"args\":&#123;\"_genkey_0\":\"/&#123;segment&#125;\"&#125;&#125; 设置响应头 在接下来的处理中修改响应头X-Response-Foo为Bar yml配置 1- SetResponseHeader =X-Request-Foo,Bar json配置 1&#123;\"name\":\"SetResponseHeader\",\"args\":&#123;\"_genkey_0\":\"X-Response-Foo\",\"_genkey_1\":\"Bar\"&#125;&#125; 设置Http状态 yml配置 123- name: SetStatus args: status: 401 json配置 1&#123;\"name\":\"SetStatus\",\"args\":&#123;\"_genkey_0\":\"302\"&#125;&#125; 设置文件传输大小 yml配置 123- name: RequestSize args: maxSize: 5000000 json配置 1&#123;\"name\":\"RequestSize\",\"args\":&#123;\"_genkey_0\":\"5000000\"&#125;&#125; 失败重试 yml配置1234- name: Retry args: retries: 3 statuses: BAD_GATEWAY","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"从零开始玩转SpringCloud（二）：Gateway网关对接注册中心","slug":"springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心","date":"2019-04-07T06:54:30.000Z","updated":"2019-04-07T06:58:46.810Z","comments":true,"path":"springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心/","link":"","permalink":"https://challange.github.io/springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心/","excerpt":"","text":"简介：Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。 项目搭建 引入依赖12345678910&lt;!--Eureka 客户端--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt;&lt;!--Gateway 路由--&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;&lt;/dependency&gt; 注意：不要引入spring-boot-starter-web包，会导致Gateway启动抛出异常，错误如下。因为Spring Cloud Gateway 是使用 netty+webflux实现，webflux与web是冲突的。1Consider defining a bean of type &apos;org.springframework.http.codec.ServerCodecConfigurer&apos; in your configuration. 在Application中使用@EnableEurekaClient 12345678910111213package com.example.gateway;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.EnableEurekaClient;@EnableEurekaClient@SpringBootApplicationpublic class GatewayApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(GatewayApplication.class, args); &#125;&#125; 配置自动将注册中心的服务映射为路由 12345678910111213141516171819server: port: 8081spring: application: name: gateway cloud: gateway: # 此处配置表示开启自动映射Eureka下发的路由 discovery: locator: enabled: true lowerCaseServiceId: trueeureka: client: # Eureka Server地址 service-url: defaultZone: http://localhost:8760/eureka/ 至此，已经可以直接通过gateway访问其他注册在Eureka中的服务的接口了。如客户端接口地址：http://localhost:8080/test，注册名称为client，则访问地址为http://localhost:8081/client/test。","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Gateway","slug":"Gateway","permalink":"https://challange.github.io/tags/Gateway/"}]},{"title":"从零开始玩转SpringCloud（一）：Eureka注册中心","slug":"springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心","date":"2019-04-07T06:50:20.000Z","updated":"2019-04-07T08:53:50.341Z","comments":true,"path":"springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心/","link":"","permalink":"https://challange.github.io/springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心/","excerpt":"","text":"Eureka 介绍：Eureka，古希腊词语，含义为我找到了，我发现了！相传阿基米德发现福利原理时说出了这个词。 Eureka是Spring Cloud Netflix微服务套件中的一部分，可以与Springboot构建的微服务很容易的整合起来。Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端组件包含服务消费者与服务生产者。在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时也可以从服务端查询当前注册的服务信息并把他们缓存到本地并周期性的刷新服务状态。 Eureka-Server服务搭建 引入依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;&lt;/dependency&gt; 在Application中使用@EnableEurekaServer 12345678910111213package com.example.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaServer@SpringBootApplicationpublic class EurekaApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaApplication.class, args); &#125;&#125; 配置文件 1234567891011121314151617181920212223242526spring: application: name: eureka-server # cAPP名称，在Eureka注册名称 profiles: active: peer eureka: instance: hostname: peer # 服务注册中心实例的主机名 client: register-with-eureka: false # 是否注册自己 fetch-registry: false serviceUrl: defaultZone: http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/ server: enableSelfPreservation: false #关闭自我保护机制logging: level: com: netflix: eureka: info discovery: infoserver: port: 8760 至此一个Eureka-Server就搭建好了。 Eureka-Server服务高可用 说到高可用，就是要保证一个节点挂掉，不会影响整个系统的运行。解决办法就是多部署几个实例，搭建集群，那么一个实例节点挂掉，其他实例仍可提供服务。 新建三个配置文件application-peer1.yml、application-peer2.yml、application-peer3， 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer1eureka: instance: hostname: peer1 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8762/eureka, http://localhost:8763/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: infoserver: port: 8761 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer2eureka: instance: hostname: peer2 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8761/eureka, http://localhost:8763/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: info server: port: 8762 123456789101112131415161718192021222324spring: application: name: eureka-server profiles: active: peer3eureka: instance: hostname: peer3 #服务注册中心实例的主机名 client: serviceUrl: # 另外几个注册中心地址 defaultZone: http://localhost:8761/eureka, http://localhost:8762/eureka server: enableSelfPreservation: false #关闭自我保护logging: level: com: netflix: eureka: info discovery: infoserver: port: 8763 idea下按配置文件启动多个项目，Active profiles指定启动配置文件。分别启动刚刚写好的三个配置文件即可。 生产环境下是否需要动态配置注册中心，目前的配置对生产环境动态配置非常不友好 客户端配置 引入Eureka Client依赖 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;&lt;/dependency&gt; 在Application中使用@EnableEurekaServer 12345678910111213package com.example.eureka;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;import org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;@EnableEurekaClient@SpringBootApplicationpublic class EurekaClientApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(EurekaClientApplication.class, args); &#125;&#125; 配置文件 12345678910111213spring: application: name: gateway # 在eureka-server注册名称 eureka: client: service-url: defaultZone: http://localhost:8760/eureka/ # #高可用配置# defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/,http://localhost:8763/eureka/ server: port: 8081 至此已EurekaClient已经搭建成功","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"https://challange.github.io/tags/SpringCloud/"},{"name":"Eureka","slug":"Eureka","permalink":"https://challange.github.io/tags/Eureka/"}]},{"title":"Scratch3.0——作品截图","slug":"scratch-Scratch3-0——作品截图","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T08:56:35.339Z","comments":true,"path":"scratch-Scratch3-0——作品截图/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——作品截图/","excerpt":"","text":"Scratch 的舞台是基于canvas，最初尝试直接通过canvas的dom，然后生成图片，但最后只能得到一个黑色的图片，得到黑色图片的原因是没有取到有效的canvas而不是因为图片跨域，当初在这里走了很多弯路，继续研究舞台组件stage.jsx，从vm.renderer可以获取canvas，于是通过这个canvas对象生成图片，记得当时的效果是偶尔会得到有效图片，但是大部分时候依然是黑色的图片，原因稍后回解释。为了实现截图，当时又进一步研究了renderer的代码，最后找到了draw方法，通过多次尝试发现在draw方法的最后执行canvas对象生成图片可以获得舞台的有效图片。 最初的笨办法在node_modules中找到scratch-render/src/RenderWebGL.js中的draw方法，也可以直接在dist中修改编译后的文件。顺便解释一下draw是对舞台进行了清理和重新绘制，而draw的频率非常频繁，因此不能直接通过canvas获取图片。在重绘后追加获取图片的toDataURL方法，考虑到需要在gui里面调用，此处采用了监听键盘事件来通信，接收到截图请求将舞台图片放在window.sessionStorage内存中，在需要使用的时候可以直接从sessionStorage获得。123456789101112131415161718192021draw () &#123; this._doExitDrawRegion(); // 获取gl const gl = this._gl; // twgl.bindFramebufferInfo(gl, null); gl.viewport(0, 0, gl.canvas.width, gl.canvas.height); gl.clearColor.apply(gl, this._backgroundColor); gl.clear(gl.COLOR_BUFFER_BIT); // 重新绘制 this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection); // 增加如下代码 let img = new Image(); img.src = gl.canvas.toDataURL('image/png',0.7) document.onkeydown = function (e) &#123; if(e.keyCode == 16)&#123; window.sessionStorage.setItem(\"coverImg\",img.src) console.log('webGL') &#125; &#125; &#125; 带来问题 直接修改node_modules依赖的内容，严重影响团队开发、项目部署，提升了项目维护的复杂度。 每次draw都会执行toDataURL方法，并且赋值，增大了系统开销。 通过事件映射，提升了项目的复杂度。 优化回归最初问题的本源，不能直接从canvas.toDataURL获得舞台截图的原因是执行toDataURL的时候可能正好draw在重绘。因此先截图前先draw然后获取图片。123this.renderer.draw();const img = new Image();img.src = this.canvas.toDataURL('image/png', 0.7); 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]},{"title":"Scratch3.0——克隆代码仓库的正确姿势","slug":"scratch-Scratch3-0——克隆代码仓库的正确姿势","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T09:02:09.586Z","comments":true,"path":"scratch-Scratch3-0——克隆代码仓库的正确姿势/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——克隆代码仓库的正确姿势/","excerpt":"","text":"对Scratch3.0进行二次开发，首先要在github上fock官方代码，但是在自己开发的同时又要跟进官方的代码就要在git做如下配置。 步骤：1、配置上游项目地址。即将你 fork 的项目的地址给配置到自己的项目上。使用以下命令来配置。1➜ git remote add upstream https://github.com/LLK/scratch-gui.git 然后可以查看一下配置状况，很好，上游项目的地址已经被加进来了。12345➜ git remote -vorigin https://github.com/***/scratch-gui.git (fetch)origin https://github.com/***/scratch-gui.git (push)upstream https://github.com/LLK/scratch-gui.git (fetch)upstream https://github.com/LLK/scratch-gui.git (push) 2、获取上游(官方)项目更新。使用 fetch 命令更新，fetch 后会被存储在一个本地分支 upstream/master 上。如果长时间没有更新，可能会非常慢，一定要在网络环境好的情况下更新或从GitHub下载代码。1➜ git fetch upstream 3、合并到本地分支。切换到 master 分支，合并 upstream/master 分支。1➜ git merge upstream/master 如果提示： fatal: refusing to merge unrelated histories，这是因为本地和远端已经是两个独立的版本库，git认为是不相干的版本库。1➜ git merge upstream/master --allow-unrelated-histories 4、合并冲突。因为是在原先代码的基础上二次开发，冲突不可避免，而最费时间的也是这里解决冲突这一步。 5、提交推送。根据自己情况提交推送自己项目的代码。1➜ git push origin master 由于项目已经配置了上游项目的地址，所以如果 fork 的项目再次更新，重复步骤 2、3、4即可。 留几个问题供大家思考交流： 冲突在所难免，在开发中注意什么可以更快更高效的解决冲突合并代码？ 如果官方代码重构了某部分模块，你的代码严重依赖该模块该如何处理？ 如果需要修改开源系统，不要改动原系统，而是要开发辅助系统。（——从零开始学架构） 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]},{"title":"Scratch3.0——项目层次结构","slug":"scratch-Scratch3-0——项目层次结构","date":"2019-04-06T08:46:31.000Z","updated":"2019-04-07T09:05:43.386Z","comments":true,"path":"scratch-Scratch3-0——项目层次结构/","link":"","permalink":"https://challange.github.io/scratch-Scratch3-0——项目层次结构/","excerpt":"","text":"简要介绍: 本文旨在介绍scratch3.0项目层次结构及关键功能。源码：https://github.com/LLK/scratch-gui 核心依赖库scratch-audio：声音拓展scratch-blocks：代码积木块scratch-l10n：国际化scratch-paint：绘图拓展scratch-render：舞台渲染，在舞台区域出现的基于WebGL的处理器。scratch-storage：作品存储加载scratch-svg-renderer：svg处理scratch-vm：虚拟机，管理状态并执行业务逻辑。 Scratch-Gui目录结构在scratch中最为核心的便是gui库，目录结构如下：123456789101112131415161718192021222324├── build # 默认编译后的文件夹│ ├── static # 静态资源│ ├── index.html │ ├── gui.js │ ├── lib.js # 编译后主要的js文件 ├── src│ ├── components # UI组件，负责页面呈现│ ├── containers # 容器组件，承载容器组件业务逻辑│ ├── css # 全局通用css│ ├── examples # 集成测试用例│ ├── extensions # 拓展案例│ ├── lib # 插件及高阶组件│ ├── audio # 声音插件│ ├── backpack # 背包插件│ ├── default-project # 默认项目│ ├── libraries # 素材库相关│ ├── video # 视频模块│ ├── playground # 编译后页面的模版│ ├── reducers # 全局状态控制├── test # 测试用例├── translations # 翻译库├── README.md└── package.json└── webpack.consig.js 码猿Scratch学习平台：https://scratch.imayuan.com","categories":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/categories/Scratch/"}],"tags":[{"name":"Scratch","slug":"Scratch","permalink":"https://challange.github.io/tags/Scratch/"}]}]}