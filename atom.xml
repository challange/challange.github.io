<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>高家祺的博客</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://challange.github.io/"/>
  <updated>2019-05-08T16:30:42.471Z</updated>
  <id>https://challange.github.io/</id>
  
  <author>
    <name>高家祺</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>云原生时代下的12-Factor应用原则</title>
    <link href="https://challange.github.io/%E5%BE%AE%E6%9C%8D%E5%8A%A1-%E4%BA%91%E5%8E%9F%E7%94%9F%E6%97%B6%E4%BB%A3%E4%B8%8B%E7%9A%8412-Factor%E5%BA%94%E7%94%A8%E5%8E%9F%E5%88%99/"/>
    <id>https://challange.github.io/微服务-云原生时代下的12-Factor应用原则/</id>
    <published>2019-05-06T08:05:05.000Z</published>
    <updated>2019-05-08T16:30:42.471Z</updated>
    
    <content type="html"><![CDATA[<blockquote><ul><li>使用标准化流程自动配置，从而使新的开发者花费<strong>最少的学习成本</strong>加入这个项目。</li><li>和操作系统之间尽可能的划清界限，在各个系统中提供最大的<strong>可移植性</strong>。</li><li>适合部署在现代的云计算平台，从而在服务器和系统管理方面<strong>节省资源</strong>。</li><li>将开发环境和生产环境的差异降至最低，并使用<strong>持续交付</strong>实施敏捷开发。</li><li><strong>易拓展</strong>：可以在工具、架构和开发流程不发生明显变化的前提下实现扩展。</li></ul></blockquote><h3 id="I-基准代码——一份基准代码（Codebase），多份部署（deploy）"><a href="#I-基准代码——一份基准代码（Codebase），多份部署（deploy）" class="headerlink" title="I. 基准代码——一份基准代码（Codebase），多份部署（deploy）"></a>I. 基准代码——一份基准代码（Codebase），多份部署（deploy）</h3><p><strong>12-Factor应用</strong>通常会使用版本控制系统加以管理，如Git, Mercurial, Subversion。一份用来跟踪代码所有修订版本的数据库被称作 <strong>代码库</strong>（code repository, code repo, repo）。在类似 SVN 这样的集中式版本控制系统中，<strong>基准代码</strong> 就是指控制系统中的这一份代码库；而在 Git 那样的分布式版本控制系统中，<strong>基准代码</strong> 则是指最上游的那份代码库。</p><p>一份代码库对应多份部署</p><p>基准代码和应用之间总是保持一一对应的关系：<br><img src="/images/云原生时代下的12-Factor应用原则/1.png" alt="Alt text"></p><p>一旦有多个基准代码，就不能称为一个应用，而是一个分布式系统。分布式系统中的每一个组件都是一个应用，每一个应用可以分别使用 12-Factor 进行开发。<br>多个应用共享一份基准代码是有悖于 12-Factor 原则的。解决方案是将共享的代码<strong>拆分</strong>为独立的类库，然后使用 <strong>依赖管理</strong> 策略去加载它们（<strong>然而多个应用共享一份基准代码缺在很多公司很常见，特别在Two B的公司，很多公司会有定制需求</strong>）。<br>尽管每个应用只对应一份基准代码，但可以同时存在多份部署。每份 <strong>部署</strong> 相当于运行了一个应用的实例。通常会有一个生产环境，一个或多个预发布环境。此外，每个开发人员都会在自己本地环境运行一个应用实例，这些都相当于一份部署。·</p><p>所有部署的基准代码相同，但每份部署可以使用其不同的版本。比如，开发人员可能有一些提交还没有同步至预发布环境；预发布环境也有一些提交没有同步至生产环境。但它们都共享一份基准代码，我们就认为它们只是相同应用的不同部署而已。</p><h3 id="II-依赖——显式声明依赖关系（-dependency-）"><a href="#II-依赖——显式声明依赖关系（-dependency-）" class="headerlink" title="II. 依赖——显式声明依赖关系（ dependency ）"></a>II. 依赖——显式声明依赖关系（ dependency ）</h3><p>大多数编程语言都会提供一个打包系统，用来为各个类库提供打包服务，就像 Perl 的 CPAN 或是 Ruby 的 Rubygems 。通过打包系统安装的类库可以是系统级的（称之为 “site packages”），或仅供某个应用程序使用，部署在相应的目录中（称之为 “vendoring” 或 “bunding”）。</p><p>12-Factor规则下的应用程序<strong>不会隐式依赖系统级的类库</strong>。 它一定通过 <strong>依赖清单</strong> ，确切地声明所有依赖项。此外，在运行过程中通过 依赖隔离 工具来确保程序不会调用系统中存在但清单中未声明的依赖项。这一做法会统一应用到生产和开发环境。</p><p>例如， Ruby 的 Bundler 使用 Gemfile 作为依赖项声明清单，使用 bundle exec 来进行依赖隔离。Python 中则可分别使用两种工具 – Pip 用作依赖声明， Virtualenv 用作依赖隔离。甚至 C 语言也有类似工具， Autoconf 用作依赖声明，静态链接库用作依赖隔离。无论用什么工具，依赖声明和依赖隔离必须一起使用，否则无法满足 12-Factor 规范。</p><p>显式声明依赖的优点之一是为新进开发者简化了环境配置流程。新进开发者可以检出应用程序的基准代码，安装编程语言环境和它对应的依赖管理工具，只需通过一个 构建命令 来安装所有的依赖项，即可开始工作。例如，Ruby/Bundler 下使用 bundle install，而 Clojure/Leiningen 则是 lein deps。</p><p>12-Factor 应用同样不会隐式依赖某些系统工具，如 ImageMagick 或是curl。即使这些工具存在于几乎所有系统，但终究无法保证所有未来的系统都能支持应用顺利运行，或是能够和应用兼容。如果应用必须使用到某些系统工具，那么这些工具应该被包含在应用之中。</p><h3 id="III-配置——在环境中存储配置"><a href="#III-配置——在环境中存储配置" class="headerlink" title="III. 配置——在环境中存储配置"></a>III. 配置——在环境中存储配置</h3><p>通常，应用的 <strong>配置</strong> 在不同 <strong>部署</strong> (预发布、生产环境、开发环境等等)间会有很大差异。这其中包括：</p><ul><li>数据库，Memcached，以及其他 后端服务 的配置</li><li>第三方服务的证书，如 Amazon S3、Twitter 等</li><li>每份部署特有的配置，如域名等</li></ul><p>有些应用在代码中使用常量保存配置，这与 12-Factor 所要求的代码和配置严格分离显然大相径庭。配置文件在各部署间存在大幅差异，代码却完全一致。</p><p>判断一个应用是否正确地将配置排除在代码之外，一个简单的方法是看该应用的基准代码是否可以立刻开源，而不用担心会暴露任何敏感的信息。</p><p>需要指出的是，这里定义的“配置”并不包括应用的内部配置，比如 Rails 的 config/routes.rb，或是使用 Spring 时 代码模块间的依赖注入关系 。这类配置在不同部署间不存在差异，所以应该写入代码。</p><p>另外一个解决方法是使用配置文件，但不把它们纳入版本控制系统，就像 Rails 的 config/database.yml 。这相对于在代码中使用常量已经是长足进步，但仍然有缺点：总是会不小心将配置文件签入了代码库；配置文件的可能会分散在不同的目录，并有着不同的格式，这让找出一个地方来统一管理所有配置变的不太现实。更糟的是，这些格式通常是语言或框架特定的。</p><p>12-Factor推荐将应用的配置存储于 <strong>环境变量</strong> 中（ env vars, env ）。环境变量可以非常方便地在不同的部署间做修改，却不动一行代码；与配置文件不同，不小心把它们签入代码库的概率微乎其微；与一些传统的解决配置问题的机制（比如 Java 的属性配置文件）相比，环境变量与语言和系统无关。</p><p>配置管理的另一个方面是分组。有时应用会将配置按照特定部署进行分组（或叫做“环境”），例如Rails中的 development,test, 和 production 环境。这种方法无法轻易扩展：更多部署意味着更多新的环境，例如 staging 或 qa 。 随着项目的不断深入，开发人员可能还会添加他们自己的环境，比如 joes-staging ，这将导致各种配置组合的激增，从而给管理部署增加了很多不确定因素。</p><p>12-Factor 应用中，环境变量的粒度要足够小，且相对独立。它们永远也不会组合成一个所谓的“环境”，而是独立存在于每个部署之中。当应用程序不断扩展，需要更多种类的部署时，这种配置管理方式能够做到平滑过渡。</p><h3 id="IV-后端服务——把后端服务当作附加资源-backing-services"><a href="#IV-后端服务——把后端服务当作附加资源-backing-services" class="headerlink" title="IV. 后端服务——把后端服务当作附加资源(backing services)"></a>IV. 后端服务——把后端服务当作附加资源(backing services)</h3><p>后端服务是指程序运行所需要的通过网络调用的各种服务，如数据库（MySQL，CouchDB），消息/队列系统（RabbitMQ，Beanstalkd），SMTP 邮件发送服务（Postfix），以及缓存系统（Memcached）。</p><p>类似数据库的后端服务，通常由部署应用程序的系统管理员一起管理。除了本地服务之外，应用程序有可能使用了第三方发布和管理的服务。示例包括 SMTP（例如 Postmark），数据收集服务（例如 New Relic 或 Loggly），数据存储服务（如 Amazon S3），以及使用 API 访问的服务（例如 Twitter, Google Maps, Last.fm）。</p><p>12-Factor 应用不会区别对待本地或第三方服务。 对应用程序而言，两种都是附加资源，通过一个 url 或是其他存储在 <strong>配置</strong> 中的服务定位/服务证书来获取数据。12-Factor 应用的任意 部署 ，都应该可以在不进行任何代码改动的情况下，将本地 MySQL 数据库换成第三方服务（例如 Amazon RDS）。类似的，本地 SMTP 服务应该也可以和第三方 SMTP 服务（例如 Postmark ）互换。上述 2 个例子中，仅需修改配置中的资源地址。</p><p>每个不同的后端服务是一份 <strong>资源</strong> 。例如，一个 MySQL 数据库是一个资源，两个 MySQL 数据库（用来数据分区）就被当作是 2 个不同的资源。12-Factor 应用将这些数据库都视作 附加资源 ，这些资源和它们附属的部署保持松耦合。</p><p>一种部署附加4个后端服务<br><img src="/images/云原生时代下的12-Factor应用原则/2.png" alt="Alt text"></p><p>部署可以按需加载或卸载资源。例如，如果应用的数据库服务由于硬件问题出现异常，管理员可以从最近的备份中恢复一个数据库，卸载当前的数据库，然后加载新的数据库 – 整个过程都不需要修改代码。</p><h3 id="V-构建，发布，运行——严格分离构建和运行"><a href="#V-构建，发布，运行——严格分离构建和运行" class="headerlink" title="V. 构建，发布，运行——严格分离构建和运行"></a>V. 构建，发布，运行——严格分离构建和运行</h3><p>基准代码 转化为一份部署(非开发环境)需要以下三个阶段：</p><ul><li><strong>构建阶段</strong> 是指将代码仓库转化为可执行包的过程。构建时会使用指定版本的代码，获取和打包 依赖项，编译成二进制文件和资源文件。</li><li><strong>发布阶段</strong> 会将构建的结果和当前部署所需 配置 相结合，并能够立刻在运行环境中投入使用。</li><li><strong>运行阶段</strong> （或者说“运行时”）是指针对选定的发布版本，在执行环境中启动一系列应用程序 进程。<br>代码被构建，然后和配置结合成为发布版本</li></ul><p>12-factor 应用严格区分构建，发布，运行这三个步骤。 举例来说，直接修改处于运行状态的代码是非常不可取的做法，因为这些修改很难再同步回构建步骤。</p><p>部署工具通常都提供了发布管理工具，最引人注目的功能是退回至较旧的发布版本。比如， Capistrano 将所有发布版本都存储在一个叫 releases 的子目录中，当前的在线版本只需映射至对应的目录即可。该工具的 rollback 命令可以很容易地实现回退版本的功能。</p><p><img src="/images/云原生时代下的12-Factor应用原则/3.png" alt="Alt text"></p><p>每一个发布版本必须对应一个唯一的发布 ID，例如可以使用发布时的时间戳（2011-04-06-20:32:17），亦或是一个增长的数字（v100）。发布的版本就像一本只能追加的账本，一旦发布就不可修改，任何的变动都应该产生一个新的发布版本。</p><p>新的代码在部署之前，需要开发人员触发构建操作。但是，运行阶段不一定需要人为触发，而是可以自动进行。如服务器重启，或是进程管理器重启了一个崩溃的进程。因此，运行阶段应该保持尽可能少的模块，这样假设半夜发生系统故障而开发人员又捉襟见肘也不会引起太大问题。构建阶段是可以相对复杂一些的，因为错误信息能够立刻展示在开发人员面前，从而得到妥善处理。</p><h3 id="VI-进程——以一个或多个无状态进程运行应用"><a href="#VI-进程——以一个或多个无状态进程运行应用" class="headerlink" title="VI. 进程——以一个或多个无状态进程运行应用"></a>VI. 进程——以一个或多个无状态进程运行应用</h3><p>运行环境中，应用程序通常是以一个和多个 进程 运行的。</p><p>最简单的场景中，代码是一个独立的脚本，运行环境是开发人员自己的笔记本电脑，进程由一条命令行（例如python my_script.py）。另外一个极端情况是，复杂的应用可能会使用很多 进程类型 ，也就是零个或多个进程实例。</p><p>12-Factor 应用的进程<strong>必须无状态且无共享</strong> 。 任何需要持久化的数据都要存储在 <strong>后端服务</strong> 内，比如数据库。</p><p>内存区域或磁盘空间可以作为进程在做某种事务型操作时的<strong>缓存</strong>，例如下载一个很大的文件，对其操作并将结果写入数据库的过程。12-Factor应用根本不用考虑这些缓存的内容是不是可以保留给之后的请求来使用，这是因为应用启动了多种类型的进程，将来的请求多半会由其他进程来服务。即使在只有一个进程的情形下，先前保存的数据（内存或文件系统中）也会因为重启（如代码部署、配置更改、或运行环境将进程调度至另一个物理区域执行）而丢失。</p><p>源文件打包工具（Jammit, django-compressor） 使用文件系统来缓存编译过的源文件。12-Factor 应用更倾向于在 构建步骤 做此动作——正如 Rails资源管道 ，而不是在运行阶段。</p><p>一些互联网系统依赖于 “粘性 session”， 这是指将用户 session 中的数据缓存至某进程的内存中，并将同一用户的后续请求路由到同一个进程。粘性 session 是 12-Factor 极力反对的。Session 中的数据应该保存在诸如 Memcached 或 Redis 这样的带有过期时间的缓存中。</p><h3 id="VII-端口绑定——通过端口绑定提供服务"><a href="#VII-端口绑定——通过端口绑定提供服务" class="headerlink" title="VII. 端口绑定——通过端口绑定提供服务"></a>VII. 端口绑定——通过端口绑定提供服务</h3><p>互联网应用有时会运行于服务器的容器之中。例如 PHP 经常作为 Apache HTTPD 的一个模块来运行，正如 Java 运行于 Tomcat 。</p><p>12-Factor 应用完全自我加载 而不依赖于任何网络服务器就可以创建一个面向网络的服务。互联网应用 通过端口绑定来提供服务 ，并监听发送至该端口的请求。</p><p>本地环境中，开发人员通过类似 <a href="http://localhost:5000/">http://localhost:5000/</a> 的地址来访问服务。在线上环境中，请求统一发送至公共域名而后路由至绑定了端口的网络进程。</p><p>通常的实现思路是，<strong>将网络服务器类库通过 依赖声明 载入应用</strong>。例如，Python 的 Tornado, Ruby 的Thin , Java 以及其他基于 JVM 语言的 Jetty。完全由 用户端 ，确切的说应该是应用的代码，发起请求。和运行环境约定好绑定的端口即可处理这些请求。</p><p>HTTP 并不是唯一一个可以由端口绑定提供的服务。其实几乎所有服务器软件都可以通过进程绑定端口来等待请求。例如，使用 XMPP 的 ejabberd ， 以及使用 Redis 协议 的 Redis 。</p><p>还要指出的是，端口绑定这种方式也意味着一个应用可以成为另外一个应用的 后端服务 ，调用方将服务方提供的相应 URL 当作资源存入 配置 以备将来调用。</p><h3 id="VIII-并发——通过进程模型进行扩展"><a href="#VIII-并发——通过进程模型进行扩展" class="headerlink" title="VIII. 并发——通过进程模型进行扩展"></a>VIII. 并发——通过进程模型进行扩展</h3><p>任何计算机程序，一旦启动，就会生成一个或多个进程。互联网应用采用多种进程运行方式。例如，PHP 进程作为 Apache 的子进程存在，随请求按需启动。Java 进程则采取了相反的方式，在程序启动之初 JVM 就提供了一个超级进程储备了大量的系统资源(CPU 和内存)，并通过多线程实现内部的并发管理。上述 2 个例子中，进程是开发人员可以操作的最小单位。</p><p>扩展表现为运行中的进程，工作多样性表现为进程类型。<br><img src="/images/云原生时代下的12-Factor应用原则/4.png" alt="Alt text"></p><p>在 12-factor 应用中，<strong>进程是一等公民</strong>。12-Factor 应用的进程主要借鉴于 <strong>unix 守护进程模型</strong> 。开发人员可以运用这个模型去设计应用架构，将不同的工作分配给不同的 进程类型 。例如，HTTP 请求可以交给 web 进程来处理，而常驻的后台工作则交由 worker 进程负责。</p><p>这并不包括个别较为特殊的进程，例如通过虚拟机的线程处理并发的内部运算，或是使用诸如 EventMachine, Twisted, Node.js 的异步/事件触发模型。但一台独立的虚拟机的扩展有瓶颈（垂直扩展），所以应用程序必须可以在多台物理机器间跨进程工作。</p><p>上述进程模型会在系统急需扩展时大放异彩。 12-Factor 应用的进程所具备的无共享，水平分区的特性 意味着添加并发会变得简单而稳妥。这些进程的类型以及每个类型中进程的数量就被称作 进程构成 。</p><p>12-Factor 应用的进程 不需要守护进程 或是写入 PID 文件。相反的，应该借助操作系统的进程管理器(例如 systemd ，分布式的进程管理云平台，或是类似 Foreman 的工具)，来管理 输出流 ，响应崩溃的进程，以及处理用户触发的重启和关闭超级进程的请求。</p><h3 id="IX-易处理——快速启动和优雅终止可最大化健壮性"><a href="#IX-易处理——快速启动和优雅终止可最大化健壮性" class="headerlink" title="IX. 易处理——快速启动和优雅终止可最大化健壮性"></a>IX. 易处理——快速启动和优雅终止可最大化健壮性</h3><p>12-Factor 应用的 进程 是 <strong>易处理</strong>（disposable）的，意思是说它们可以<strong>瞬间开启或停止</strong>。 这有利于快速、弹性的伸缩应用，迅速部署变化的 代码 或 配置 ，稳健的部署应用。</p><p>进程应当追求 最小启动时间 。 理想状态下，进程从敲下命令到真正启动并等待请求的时间应该只需很短的时间。更少的启动时间提供了更敏捷的 发布 以及扩展过程，此外还增加了健壮性，因为进程管理器可以在授权情形下容易的将进程搬到新的物理机器上。</p><p>进程 一旦接收 <strong>终止信号</strong>（SIGTERM） 就会优雅的终止 。就网络进程而言，优雅终止是指停止监听服务的端口，即拒绝所有新的请求，并继续执行当前已接收的请求，然后退出。此类型的进程所隐含的要求是HTTP请求大多都很短(不会超过几秒钟)，而在长时间轮询中，客户端在丢失连接后应该马上尝试重连。</p><p>对于 worker 进程来说，优雅终止是指将当前任务退回队列。例如，RabbitMQ 中，worker 可以发送一个NACK信号。 Beanstalkd 中，任务终止并退回队列会在worker断开时自动触发。有锁机制的系统诸如 Delayed Job 则需要确定释放了系统资源。此类型的进程所隐含的要求是，任务都应该 可重复执行 ， 这主要由将结果包装进事务或是使重复操作 幂等 来实现。</p><p>进程还应当在面对突然死亡时保持健壮，例如底层硬件故障。虽然这种情况比起优雅终止来说少之又少，但终究有可能发生。一种推荐的方式是使用一个健壮的后端队列，例如 Beanstalkd ，它可以在客户端断开或超时后自动退回任务。无论如何，12-Factor 应用都应该可以设计能够应对意外的、不优雅的终结。Crash-only design 将这种概念转化为 合乎逻辑的理论。</p><h3 id="X-开发环境与线上环境等价——尽可能的保持开发，预发布，线上环境相同"><a href="#X-开发环境与线上环境等价——尽可能的保持开发，预发布，线上环境相同" class="headerlink" title="X. 开发环境与线上环境等价——尽可能的保持开发，预发布，线上环境相同"></a>X. 开发环境与线上环境等价——尽可能的保持开发，预发布，线上环境相同</h3><p>从以往经验来看，开发环境（即开发人员的本地 部署）和线上环境（外部用户访问的真实部署）之间存在着很多差异。这些差异表现在以下三个方面：</p><ul><li>时间差异： 开发人员正在编写的代码可能需要几天，几周，甚至几个月才会上线。</li><li>人员差异： 开发人员编写代码，运维人员部署代码。</li><li><p>工具差异： 开发人员或许使用 Nginx，SQLite，OS X，而线上环境使用 Apache，MySQL 以及 Linux。<br>12-Factor 应用想要做到 <strong>持续部署</strong> 就必须<strong>缩小本地与线上差异</strong>。 再回头看上面所描述的三个差异:</p></li><li><p>缩小时间差异：开发人员可以几小时，甚至几分钟就部署代码。</p></li><li>缩小人员差异：开发人员不只要编写代码，更应该密切参与部署过程以及代码在线上的表现。</li><li>缩小工具差异：尽量保证开发环境以及线上环境的一致性。<br>将上述总结变为一个表格如下：</li></ul><table><thead><tr><th style="text-align:left">Item</th><th style="text-align:right">传统应用</th><th style="text-align:center">12-Factor 应用</th></tr></thead><tbody><tr><td style="text-align:left">每次部署间隔</td><td style="text-align:right">数周</td><td style="text-align:center">几个小时</td></tr><tr><td style="text-align:left">开发人员 vs 运维人员</td><td style="text-align:right">不同的人</td><td style="text-align:center">相同的人</td></tr><tr><td style="text-align:left">开发环境 vs 线上环境</td><td style="text-align:right">不同</td><td style="text-align:center">尽量接近</td></tr></tbody></table><p>后端服务 是保持开发与线上等价的重要部分，例如数据库，队列系统，以及缓存。许多语言都提供了简化获取后端服务的类库，例如不同类型服务的 适配器 。下列表格提供了一些例子。</p><table><thead><tr><th style="text-align:left">类型</th><th style="text-align:right">语言</th><th style="text-align:center">类库</th><th style="text-align:center">适配器</th></tr></thead><tbody><tr><td style="text-align:left">数据库</td><td style="text-align:right">Ruby/Rails</td><td style="text-align:center">ActiveRecord</td><td style="text-align:center">MySQL, PostgreSQL, SQLite</td></tr><tr><td style="text-align:left">队列</td><td style="text-align:right">Python/Django</td><td style="text-align:center">Celery</td><td style="text-align:center">RabbitMQ, Beanstalkd, Redis</td></tr><tr><td style="text-align:left">缓存</td><td style="text-align:right">Ruby/Rails</td><td style="text-align:center">ActiveSupport::Cache</td><td style="text-align:center">Memory, filesystem,Memcached</td></tr></tbody></table><p>开发人员有时会觉得在本地环境中使用轻量的后端服务具有很强的吸引力，而那些更重量级的健壮的后端服务应该使用在生产环境。例如，本地使用 SQLite 线上使用 PostgreSQL；又如本地缓存在进程内存中而线上存入 Memcached。</p><p>12-Factor 应用的开发人员应该反对在不同环境间使用不同的后端服务 ，即使适配器已经可以几乎消除使用上的差异。这是因为，不同的后端服务意味着会突然出现的不兼容，从而导致测试、预发布都正常的代码在线上出现问题。这些错误会给持续部署带来阻力。从应用程序的生命周期来看，消除这种阻力需要花费很大的代价。</p><p>与此同时，轻量的本地服务也不像以前那样引人注目。借助于Homebrew，apt-get等现代的打包系统，诸如Memcached、PostgreSQL、RabbitMQ 等后端服务的安装与运行也并不复杂。此外，使用类似 Chef 和 Puppet 的声明式配置工具，结合像 Vagrant 这样轻量的虚拟环境就可以使得开发人员的本地环境与线上环境无限接近。与同步环境和持续部署所带来的益处相比，安装这些系统显然是值得的。</p><p>不同后端服务的适配器仍然是有用的，因为它们可以使移植后端服务变得简单。但应用的所有部署，这其中包括开发、预发布以及线上环境，都应该使用同一个后端服务的相同版本。</p><h3 id="XI-日志——把日志当作事件流"><a href="#XI-日志——把日志当作事件流" class="headerlink" title="XI. 日志——把日志当作事件流"></a>XI. 日志——把日志当作事件流</h3><p><strong>日志</strong> 使得应用程序运行的动作变得透明。在基于服务器的环境中，日志通常被写在硬盘的一个文件里，但这只是一种输出格式。</p><p>日志应该是 <strong>事件流</strong> 的汇总，将所有运行中进程和后端服务的输出流按照时间顺序收集起来。尽管在回溯问题时可能需要看很多行，日志最原始的格式确实是一个事件一行。日志没有确定开始和结束，但随着应用在运行会持续的增加。</p><p>12-factor应用本身从不考虑存储自己的输出流。 不应该试图去写或者管理日志文件。相反，每一个运行的进程都会直接的标准输出（stdout）事件流。开发环境中，开发人员可以通过这些数据流，实时在终端看到应用的活动。</p><p>在预发布或线上部署中，每个进程的输出流由运行环境截获，并将其他输出流整理在一起，然后一并发送给一个或多个最终的处理程序，用于查看或是长期存档。这些存档路径对于应用来说不可见也不可配置，而是完全交给程序的运行环境管理。类似 Logplex 和 Fluentd 的开源工具可以达到这个目的。</p><p>这些事件流可以输出至文件，或者在终端实时观察。最重要的，输出流可以发送到 Splunk 这样的日志索引及分析系统，或 Hadoop/Hive 这样的通用数据存储系统。这些系统为查看应用的历史活动提供了强大而灵活的功能，包括：</p><ul><li>找出过去一段时间特殊的事件。</li><li>图形化一个大规模的趋势，比如每分钟的请求量。</li><li>根据用户定义的条件实时触发警报，比如每分钟的报错超过某个警戒线。</li></ul><h3 id="XII-管理进程——后台管理任务当作一次性进程运行"><a href="#XII-管理进程——后台管理任务当作一次性进程运行" class="headerlink" title="XII. 管理进程——后台管理任务当作一次性进程运行"></a>XII. 管理进程——后台管理任务当作一次性进程运行</h3><p><strong>进程构成</strong>（process formation）是指用来处理应用的常规业务（比如处理 web 请求）的一组进程。与此不同，开发人员经常希望执行一些管理或维护应用的一次性任务，例如：</p><ul><li>运行数据移植（Django 中的 manage.py migrate, Rails 中的 rake db:migrate）。</li><li>运行一个控制台（也被称为 REPL shell），来执行一些代码或是针对线上数据库做一些检查。大多数语言都通过解释器提供了一个 REPL 工具（python 或 perl） ，或是其他命令（Ruby 使用 irb, Rails 使用 rails console）。</li><li>运行一些提交到代码仓库的一次性脚本。</li></ul><p>一次性管理进程应该和正常的 <strong>常驻进程</strong> 使用同样的环境。这些管理进程和任何其他的进程一样使用相同的 代码 和 配置 ，基于某个 <strong>发布版本</strong> 运行。后台管理代码应该随其他应用程序代码一起发布，从而避免同步问题。</p><p>所有进程类型应该使用同样的 <strong>依赖隔离</strong> 技术。例如，如果Ruby的web进程使用了命令 bundle exec thin start ，那么数据库移植应使用 bundle exec rake db:migrate 。同样的，如果一个 Python 程序使用了 Virtualenv，则需要在运行 Tornado Web 服务器和任何 manage.py 管理进程时引入 bin/python 。</p><p>12-factor 尤其青睐那些提供了 REPL shell 的语言，因为那会让运行一次性脚本变得简单。在本地部署中，开发人员直接在命令行使用 shell 命令调用一次性管理进程。在线上部署中，开发人员依旧可以使用ssh或是运行环境提供的其他机制来运行这样的进程。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;使用标准化流程自动配置，从而使新的开发者花费&lt;strong&gt;最少的学习成本&lt;/strong&gt;加入这个项目。&lt;/li&gt;
&lt;li&gt;和操作系统之间尽可能的划清界限，在各个系统中提供最大的&lt;strong&gt;可移植性&lt;/strong&gt;。&lt;/li&gt;

      
    
    </summary>
    
      <category term="微服务" scheme="https://challange.github.io/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
    
      <category term="微服务" scheme="https://challange.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Git操作整理</title>
    <link href="https://challange.github.io/Git-GIt%E6%93%8D%E4%BD%9C%E6%95%B4%E7%90%86/"/>
    <id>https://challange.github.io/Git-GIt操作整理/</id>
    <published>2019-05-06T08:05:05.000Z</published>
    <updated>2019-05-08T16:24:18.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基础操作"><a href="#基础操作" class="headerlink" title="基础操作"></a>基础操作</h3><h4 id="查看全局配置信息"><a href="#查看全局配置信息" class="headerlink" title="查看全局配置信息"></a>查看全局配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --list</span><br></pre></td></tr></table></figure><h4 id="设置全局配置信息"><a href="#设置全局配置信息" class="headerlink" title="设置全局配置信息"></a>设置全局配置信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;wwyz&quot;</span><br></pre></td></tr></table></figure><h4 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h4 id="将文件加入git版本库"><a href="#将文件加入git版本库" class="headerlink" title="将文件加入git版本库"></a>将文件加入git版本库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &quot;文件名&quot;</span><br></pre></td></tr></table></figure><h4 id="拉取代码"><a href="#拉取代码" class="headerlink" title="拉取代码"></a>拉取代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone &quot;版本库地址&quot; &quot;目录名&quot;</span><br></pre></td></tr></table></figure><h4 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure><h4 id="提交代码"><a href="#提交代码" class="headerlink" title="提交代码"></a>提交代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git commit &quot;说明&quot;</span><br><span class="line">git commit --amend # 重新提交</span><br></pre></td></tr></table></figure><h4 id="移除文件-移除后文件不在被版本控制"><a href="#移除文件-移除后文件不在被版本控制" class="headerlink" title="移除文件,移除后文件不在被版本控制"></a>移除文件,移除后文件不在被版本控制</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm</span><br><span class="line">git rm --cached readme.txt #缓存中移除</span><br></pre></td></tr></table></figure><h4 id="移动文件"><a href="#移动文件" class="headerlink" title="移动文件"></a>移动文件</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git mv &quot;文件路径&quot; &quot;目标文件路径&quot;</span><br></pre></td></tr></table></figure><h4 id="查看提交文件历史"><a href="#查看提交文件历史" class="headerlink" title="查看提交文件历史"></a>查看提交文件历史</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br><span class="line">git log -p -2 #-p选项展开显示每次提交的内容差异，用-2则仅显示最近的两次更新</span><br></pre></td></tr></table></figure><h4 id="查看远程仓库"><a href="#查看远程仓库" class="headerlink" title="查看远程仓库"></a>查看远程仓库</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line"># 添加远程仓库</span><br><span class="line">git remote add pb git://github.com/paulboone/ticgit.git</span><br><span class="line"># 拉取远程代码更新</span><br><span class="line">git fetch pb</span><br><span class="line"># 查看远程仓库的信息</span><br><span class="line">git remote show origin</span><br></pre></td></tr></table></figure><h4 id="推送提交的代码"><a href="#推送提交的代码" class="headerlink" title="推送提交的代码"></a>推送提交的代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><blockquote><p>通过在项目根目录配置.gitignore文件忽略要忽略的文件/文件夹。<br>Java项目一般忽略：.idea、target、out、classes<br>前端项目一般忽略：.idea、node_modules、dist<br> .gitignore 格式规范如下：</p><ol><li>所有空行或者以注释符号 ＃ 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob(shell 所使用的简化了的正则表达式)模式匹配。</li><li>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</li></ol></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*.[oa]  # 忽略所有以 .o 或 .a 结尾的文件</span><br><span class="line">*~      # 忽略所有以波浪符（~）结尾的文件</span><br></pre></td></tr></table></figure><h4 id="Tag打标签"><a href="#Tag打标签" class="headerlink" title="Tag打标签"></a>Tag打标签</h4><blockquote><p>对某一时间点上的版本打上标签，通常结合版本使用。Git 使用的标签有两种类型：轻量级的（lightweight）和含附注的（annotated）。轻量级标签就像是个不会变化的分支，实际上它就是个指向特定提交对象的引用。而含附注标签，实际上是存储在仓库中的一个独立对象，它有自身的校验和信息，包含着标签的名字，电子邮件地址和日期，以及标签说明，标签本身也允许使用 GNU Privacy Guard (GPG) 来签署或验证。一般我们都建议使用含附注型的标签，以便保留相关信息；当然，如果只是临时性加注标签，或者不需要旁注额外信息，用轻量级标签也没问题。</p></blockquote><h5 id="列出已有标签"><a href="#列出已有标签" class="headerlink" title="列出已有标签"></a>列出已有标签</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><blockquote><p>使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。在很多版本控制系统中，这是个昂贵的过程，常常需要创建一个源代码目录的完整副本，对大型项目来说会花费很长时间。有人把 Git 的分支模型称为“必杀技特性”，而正是因为它，将 Git 从版本控制系统家族里区分出来。Git 有何特别之处呢？Git 的分支可谓是难以置信的轻量级，它的新建操作几乎可以在瞬间完成，并且在不同分支间切换起来也差不多一样快。</p></blockquote><h4 id="什么是分支"><a href="#什么是分支" class="headerlink" title="什么是分支"></a>什么是分支</h4><blockquote><p>在 Git 中提交时，会保存一个提交（commit）对象，该对象包含一个指向暂存内容快照的指针，包含本次提交的作者等相关附属信息，包含零个或多个指向该提交对象的父对象指针：首次提交是没有直接祖先的，普通提交有一个祖先，由两个或多个分支合并产生的提交则有多个祖先。</p></blockquote><h4 id="新建分支"><a href="#新建分支" class="headerlink" title="新建分支"></a>新建分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch &quot;分支名&quot;</span><br></pre></td></tr></table></figure><h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a>切换分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout &quot;分支名&quot;</span><br></pre></td></tr></table></figure><h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a>合并分支</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 将其他分支合并到本分支</span><br><span class="line">git merge &quot;分支名&quot;</span><br></pre></td></tr></table></figure><h4 id="分支变基"><a href="#分支变基" class="headerlink" title="分支变基"></a>分支变基</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git rebase</span><br><span class="line">#  将多次提交合并为一次提交，-i表示弹出交互式的界面让用户编辑完成合并操作</span><br><span class="line">git rebase -i  &quot;开始提交点&quot; &quot;结束提交点&quot;</span><br><span class="line"># 将某一段commit粘贴到另一个分支上</span><br><span class="line">git rebase &quot;开始提交点&quot; &quot;结束提交点&quot;  --onto &quot;分支名称&quot;</span><br></pre></td></tr></table></figure><hr><h4 id="Git官方文档"><a href="#Git官方文档" class="headerlink" title="Git官方文档"></a><a href="https://git-scm.com/book/zh/v2">Git官方文档</a></h4><h4 id="Git教程-廖雪峰"><a href="#Git教程-廖雪峰" class="headerlink" title="Git教程-廖雪峰"></a><a href="https://www.liaoxuefeng.com/wiki/896043488029600">Git教程-廖雪峰</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基础操作&quot;&gt;&lt;a href=&quot;#基础操作&quot; class=&quot;headerlink&quot; title=&quot;基础操作&quot;&gt;&lt;/a&gt;基础操作&lt;/h3&gt;&lt;h4 id=&quot;查看全局配置信息&quot;&gt;&lt;a href=&quot;#查看全局配置信息&quot; class=&quot;headerlink&quot; title=&quot;查
      
    
    </summary>
    
      <category term="Git" scheme="https://challange.github.io/categories/Git/"/>
    
    
      <category term="Git" scheme="https://challange.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习——泛型</title>
    <link href="https://challange.github.io/DIY-DIY%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <id>https://challange.github.io/DIY-DIY——泛型/</id>
    <published>2019-05-06T08:05:05.000Z</published>
    <updated>2019-05-08T16:13:41.420Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Java如果没有泛型会有什么灾难？"><a href="#1-Java如果没有泛型会有什么灾难？" class="headerlink" title="1. Java如果没有泛型会有什么灾难？"></a>1. Java如果没有泛型会有什么灾难？</h3><p>泛型是参数化类型，在使用时告诉编辑器使用什么类型。</p><ol><li><p>程序可控性：泛型有限定类型，泛型可以使程序执行时的类型是确定的，避免了程序的不可控性。在泛型引入之前，对于不确定类型需要使用Object，然后类型强转，此处带来的问题，Object含义不清，使代码不易懂，同时类型无界限限定，很可能会想当然使用错误类型。泛型的引入，在开发是对类或者方法的范围做一个限定，使类和方法运行在有限的类型中，<strong>使程序更清晰，可控性更强</strong><br><img src="/images/DIY——泛型/1.png" alt="Alt text"></p><blockquote><p>上图是ArrayList的add操作，jdk1.5前参数为Object，也就意味着任何类型都可以放入list中。 </p></blockquote></li><li><p>提升复用性：解耦类或方法对类型之间的约束，通过参数化类型，使执行相同功能的方法、类能够复用代码，如果没有泛型，相同的代码每个类都要写一份，带来了大量冗余代码。一个场景，CRUD在web项目广泛使用，逻辑类似，每个类型写一遍crud方法就会造成很多冗余代码，这时可以封装一个泛型基类，一份代码给所有类型用。</p></li><li>使用泛型，编译时就能确保容器中插入对象的类型安全，编译器发现问题要好于运行时发现问题，运行时出问题很有可能就意味着生产事故了。我们应该避免产生<strong>隐藏较深</strong>的bug，让bug越早暴露越好。<h3 id="2-List-lt-extends-T-gt-和List-lt-super-T-gt-有哪些区别？"><a href="#2-List-lt-extends-T-gt-和List-lt-super-T-gt-有哪些区别？" class="headerlink" title="2. List&lt;? extends T&gt;和List&lt;? super T&gt;有哪些区别？"></a>2. List&lt;? extends T&gt;和List&lt;? super T&gt;有哪些区别？</h3></li><li>List&lt;? extends T&gt;，Get Frist适用于消费集合为主的场景，List&lt;? extends T&gt;可以赋值给任何T及T子类的场景，上界为T，put受限，add只能放入null，不能放入其他元素;使用List&lt;? extends T&gt;相当于一个视图，不具有修改能力，但被赋值的原集合修改，视图可以感知。</li><li>List&lt;? super T&gt;，Put Frist适用于生产集合为主的场景，List&lt;? super T&gt;可以赋值给任何T及T的父类集合，下界为T，put可以放入T及T的父类类型，get受限，get可以使用，但是类型会被擦除到Object。</li><li>不同点维度:赋值，put、get</li><li>List&lt;? extends T&gt;类比于数据库的视图，T决定了结果集列的属性，相同与视图的List&lt;? extends T&gt;也是主要用于展示，如果要添加或者删除记录，则应修改原先的list。</li></ol><h3 id="3-类名-lt-super-T-gt-存在哪些实际应用场景？（参考Comparator）"><a href="#3-类名-lt-super-T-gt-存在哪些实际应用场景？（参考Comparator）" class="headerlink" title="3. 类名&lt;? super T&gt;存在哪些实际应用场景？（参考Comparator）"></a>3. 类名&lt;? super T&gt;存在哪些实际应用场景？（参考Comparator）</h3><p>Comparator&lt;? super T&gt; 准许为所有的子类使用相同的比较器。通常我们会使用Comparator自己定义对象的比较规则，如果要比较猫的重量，那么就实现猫重量的比较器，比较狗的重量，则需要实现狗重量的比较器，但如果要允许将猫与狗的重量进行比较，则就需要Comparator&lt;? super T&gt;来发挥作用，定义animal的比较器，就可以比较猫和狗的重量。&lt;? super T&gt;使的方法可以使方法不仅可以作用于父类也可以作用于子类，增加了代码的复用性。</p><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>泛型会擦除传入实体的属性，如果使用&lt; T &gt;，则T的类型在代码执行时会被擦除，因为Object是所有类的父类，所以此时T只具有Object的属性，但是当使用&lt; ? super T&gt;或&lt;? extends T&gt; ,定义边界，T的类型会被保留到边界T。</p><p>泛型在Java1.5引入，在泛型引入前java语言已经有了广泛的发展，较好的生态，拥有大量的类库，因此java在引入泛型的同时，也考虑到了兼容过去代码（java升级良好的兼容性我想是java能够经久不衰的重要原因）。java的泛型是具有类型擦除特性的<br>泛型具有类型推断能力，但是类型推断仅在赋值时有效。如果将泛型方法返回结果作为参数，这时并不会执行类型推断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Java如果没有泛型会有什么灾难？&quot;&gt;&lt;a href=&quot;#1-Java如果没有泛型会有什么灾难？&quot; class=&quot;headerlink&quot; title=&quot;1. Java如果没有泛型会有什么灾难？&quot;&gt;&lt;/a&gt;1. Java如果没有泛型会有什么灾难？&lt;/h3&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="Java基础" scheme="https://challange.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DIY" scheme="https://challange.github.io/tags/DIY/"/>
    
      <category term="Java基础" scheme="https://challange.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
      <category term="泛型" scheme="https://challange.github.io/tags/%E6%B3%9B%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java基础学习——Lambda表达式</title>
    <link href="https://challange.github.io/DIY-DIY%E2%80%94%E2%80%94Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://challange.github.io/DIY-DIY——Lambda表达式/</id>
    <published>2019-05-06T08:05:05.000Z</published>
    <updated>2019-05-08T16:09:30.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="函数式编程是什么"><a href="#函数式编程是什么" class="headerlink" title="函数式编程是什么"></a>函数式编程是什么</h3><blockquote><p>函数式编程，是一种使用函数进行编程的方式，一个“函数”对应于一个数学函数:它接受零个或多个参数，生成一个或多个结果，并且不会有任何副作用，函数式函数无论在何处、何时、何地对于同样的输入总会返回相同的结果。</p></blockquote><h3 id="一、函数式编程优劣势对比"><a href="#一、函数式编程优劣势对比" class="headerlink" title="一、函数式编程优劣势对比"></a>一、函数式编程优劣势对比</h3><h4 id="匿名类与Lambda表达式"><a href="#匿名类与Lambda表达式" class="headerlink" title="匿名类与Lambda表达式"></a>匿名类与Lambda表达式</h4><p>代码简洁，相较于匿名内部类，Lambda表达式大大简化了代码量,代码可读性也会更好<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Runnable r1 = <span class="keyword">new</span> Runnable()&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">Runnable r2 = () -&gt; System.out.println(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure></p><p><strong>局限</strong>：</p><ol><li>匿名类与lambda表达式中的this和super含义是不同的，在匿名类中，this代表自身，而lambda代表的是包含类。</li><li><p>匿名类可以屏蔽包含类的变量，而lambda不能，但是与包含类使用相同的变量，变量就容易产生歧义，难于理解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int a = 10;</span><br><span class="line">Runnable r1 = () -&gt; &#123;</span><br><span class="line">//   int a = 10;  // 编译错误</span><br><span class="line">     int a1 = 10;</span><br><span class="line">     System.out.println(a1);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>在涉及重载的方法，Lambda表达式可能会导致模棱两可，但可以通过强制类型转换来解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Task</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Runnable r)</span></span>&#123;</span><br><span class="line">    r.run();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">(Task r)</span></span>&#123;</span><br><span class="line">    r.execute();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Error:(19, 9) java: 对doSomething的引用不明确</span></span><br><span class="line"><span class="comment">// doSomething(() -&gt; System.out.println("1234"));</span></span><br><span class="line">    doSomething((Task) () -&gt; System.out.println(<span class="string">"1234"</span>));</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="行为参数化"><a href="#行为参数化" class="headerlink" title="行为参数化"></a>行为参数化</h4><p><strong>Lambda表达式引入了将方法作为参数传递的能力</strong>，在环绕场景下（一个方法只有中间部分逻辑不一样），增加了方法的复用，减少代码冗余。结合泛型理解，泛型使类或方法可以复用于更多的变量类型， 而函数式则进一步拓展了方法的复用性。<br><strong>局限</strong>：</p><ol><li>提供行为参数化后，如果行为较为复杂，则很难一眼看出行为的含义，这时候就会降低代码的可读性，相较而言，命名规范的函数则有见名知意的好处。</li></ol><h4 id="无副作用纯函数，引用透明"><a href="#无副作用纯函数，引用透明" class="headerlink" title="无副作用纯函数，引用透明"></a>无副作用纯函数，引用透明</h4><p>所谓共享数据就是数据可能被多个方法读取更新，在并发使用数据的时候必须通过上锁来确保线程安全。函数式编程所倡导的避免共享可变数据，只要参数确定就一定会返回确定结果，增加程序的可控性，不用考虑复杂易错的锁机制，使并行更加容易，充分利用计算机多核优势。</p><p><img src="/images/DIY——Lambda表达式/1.png" alt="Alt text"><br>为了维持不可变性，“函数式”的函数或者方法都只能修改本地变量，并且它引用的对象都应是不可变对象.。</p><p><strong>局限</strong>：</p><ol><li>为了确保避免共享可变数据引入——增加定义变量与赋值——增大了空间的使用</li></ol><h4 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h4><p>函数式要求函数或者方法不应抛出任何异常，因为一旦抛出异常，结果就被终止了；类比于数学函数，传入一个<strong>合法</strong>的参数，一定会返回一个确定的结果。在不使用异常的情况下，Java8引入了Optional&lt; T&gt;类型来承载异常情况，如果异常不能返回结果则返回一个空的optional对象。</p><h4 id="声明式编程"><a href="#声明式编程" class="headerlink" title="声明式编程"></a>声明式编程</h4><p>经典的面向对象编程我们专注于<strong>如何实现</strong>，思维模式为：“首先做这个，紧接着更新那个，然后……”，面向对象是抽象对象、对象之间的交互；而函数式编程更关注与<strong>要做什么</strong>，Stream流是典型的应用，采用这种“要做什么”风格的编程就是声明式编程，编程者考虑的是指定规则，而由系统或者封装来觉得如何实现这个目标。这样带来的好处是<strong>让代码更加接近于问题陈述</strong>。</p><p>习惯于声明式编程思维，我们可以更容易的利用化归思想，将复杂问题拆分为若干小问题逐步解决，自顶向下，开始更加关注于函数的输入以及输出结果，而不是过早的考虑如何做、修改哪些东西。</p><h4 id="高阶函数与科里化"><a href="#高阶函数与科里化" class="headerlink" title="高阶函数与科里化"></a>高阶函数与科里化</h4><p>满足接受一个或多个函数作为参数或返回结果是一个函数的函数都是高阶函数，高阶函数提供了链式调用的功能。</p><p>科里化是一种将具备2个参数（比如，x和y）的函数f转化为使用一个参数的函数g，并且这个函数的返回值也是一个函数，它可以作为新的函数的一个参数。后者返回值与初始函数返回值，f(x,y)=(g(x))y</p><p>高阶函数与科里化也使声明式编程可以更加运用自如。</p><h4 id="延迟计算与惰性求值"><a href="#延迟计算与惰性求值" class="headerlink" title="延迟计算与惰性求值"></a>延迟计算与惰性求值</h4><p>延迟计算以Stream为例，向Stream发起的一系列中间操作会先被一一保存起来，直到发起一个终端操作（Stream分为中间操作和中端操作，中间操作返回一个Stream，终端操作从流水线生成结果），才会进行实际的计算。延迟计算与惰性求值使得代码具备了巨大的优化潜能。支持惰性求值的编译器会像数学家看待代数表达式那样看待函数式程序:抵消相同项从而避免执行无谓的代码，优化代码的执行顺序从而实现更高的执行效率甚至是减少错误。<br>局限</p><ol><li>惰性求值最大的问题还是惰性，现实世界中很多问题还是需要严格求值的，需要严格的顺序执行，如System.nextLine()每次会读取下一行记录</li><li></li></ol><h4 id="测试与调试"><a href="#测试与调试" class="headerlink" title="测试与调试"></a>测试与调试</h4><blockquote><p>许多同学提到函数式程序难调试，个人觉得并不是因为难调试，而是我们要掌握调试的方法和工具</p></blockquote><ol><li><strong>单元测试</strong>：因为函数式程序无副作用的特性使得单元测试更加容易，唯一需要做的就是传递一些可以代表边界条件的参数给这些函数并返回确定的结果，并且不会受其他因素干扰，如调用顺序、外部状态干扰等。<br>Lambda没有函数名，的确带来了测试困难，这时可以借助某个字段访问Lambda函数来测试函数内封装的逻辑，可能又会问每个表达式定义一个变量做测试也太麻烦了，从声明式编程的角度出发，我们应该关注的是一个方法的可靠性，每个lambda仅仅是函数的实现细节，当放在函数内整体测试。</li><li><strong>Java Stream Debugger</strong><br>工欲善其事必先利其器，推荐个调试插件<strong>Java Stream Debugger</strong>，可以以可视化的形式展现stream筛选过滤的过程。<br><img src="/images/DIY——Lambda表达式/2.png" alt="Alt text"></li><li><strong>日志输出</strong><br>使用peek方法可以在stream输Alt text出当前执行的元素，便于判断问题。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;People&gt; list = peopleList.stream()</span><br><span class="line">            .peek(x -&gt; System.out.println(<span class="string">"frist:"</span>+x))</span><br><span class="line">            .filter(item -&gt; item != <span class="keyword">null</span>)</span><br><span class="line">            .peek(x -&gt; System.out.println(<span class="string">"second:"</span>+x))</span><br><span class="line">            .filter(item -&gt; item.getAge() &gt; <span class="number">5</span>)</span><br><span class="line">            .peek(x -&gt; System.out.println(<span class="string">"three:"</span>+x))</span><br><span class="line">            .collect(Collectors.toList());</span><br></pre></td></tr></table></figure></li></ol><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><ol><li>在Java7引入了InvokeDynamic指令，用于支持在JVM上运行动态类型语言，Lambda表达式使用InvokeDynamic指令使表达式转化为字节码推迟到了<strong>运行时</strong>，避免了静态初始化，生成大量的匿名类，由此带来的问题，函数首次运行需要先进行编译，也就造成首次运行可能会占用较长时间，因此需要注意预热。</li><li>包装类型转换往往不易发现，需要重点关注</li><li>总的来说lambda不会对程序性能带来提升，甚至有可能性能下降，但是我们还是得拥抱它，因为它在多核并行计算、代码可读性、可拓展行上的优势足以抵消它降低的性能。</li></ol><h4 id="其他问题："><a href="#其他问题：" class="headerlink" title="其他问题："></a>其他问题：</h4><ol><li>增加了使用门槛，但是工欲善其事必先利其器，作为一个合格Java程序猿本身就应具备持续的学习能力</li></ol><h3 id="二、Stream流的哪一个方法最有价值，为什么？"><a href="#二、Stream流的哪一个方法最有价值，为什么？" class="headerlink" title="二、Stream流的哪一个方法最有价值，为什么？"></a>二、Stream流的哪一个方法最有价值，为什么？</h3><blockquote><p>同学们为自己心目中最有价值的Stream流方法进行了投票，投票结果来看最受欢迎的三个方法是filter、map、collect，filter主要因为可以进行条件过滤，map方法则可以映射每个元素生成新的元素，collect则是最后收集元素必不可少的一环，这三个方法无疑是Stream流操作最常用的方法。</p></blockquote><p><img src="/images/DIY——Lambda表达式/3.png" alt="Alt text"></p><p>简单讲一下流的定义：<strong>从支持数据处理的源生成的元素序列</strong>。</p><blockquote><ul><li><strong>元素序列</strong>——流提供了可以访问特定元素类型的一组有序值的接口。流的目的在于表达计算，比如前面见到的 filter、sorted和map。</li><li><strong>源</strong>——流会使用一个提供数据的源，如集合、数组或输入/输出资源。</li><li><strong>数据处理操作</strong>——流的数据处理功能支持类似于数据库的操作，以及函数式编程语言中 的常用操作，如filter、map、reduce、find、match、sort等。流操作可以顺序执行，也可并行执行。</li></ul></blockquote><p>流的另外两个特点</p><blockquote><ul><li><strong>流水线</strong>——很多流操作本身会返回一个流，这样多个操作就可以链接起来，形成一个大<br>的流水线。流水线背后其实是一种建造者模式</li><li><strong>内部迭代</strong>——与使用迭代器显式迭代的集合不同，流的迭代操作是在背后进行的。</li></ul></blockquote><p>流的使用一般包括三件事:</p><blockquote><ul><li>一个数据源(如集合)来执行一个查询;</li><li>一个中间操作链，形成一条流的流水线;</li><li>一个终端操作，执行流水线，并能生成结果。</li></ul></blockquote><p><strong>parallelStream与parallel区别</strong>：<br>parallelStream是Collection接口定义的方法，在stream构造时传入参数使用parallel生成并行流。parallel是BaseStream的一个方法，能够将一个顺序流转化为一个并行流，因此在执行parallel前可以以顺序流先进行预处理。<br>如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static long parallelSum(long n) &#123;</span><br><span class="line">        return Stream.iterate(1L, i -&gt; i + 1)</span><br><span class="line">                     .limit(n)</span><br><span class="line">                     .parallel()      // 转化为并行流</span><br><span class="line">                     .reduce(0L, Long::sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>Stream流方法的使用<img src="/images/DIY——Lambda表达式/4.png" alt="Alt text"></p><p>参考文章：<br><a href="https://www.kancloud.cn/kancloud/functional-programm-for-rest/56930">傻瓜函数式编程</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;函数式编程是什么&quot;&gt;&lt;a href=&quot;#函数式编程是什么&quot; class=&quot;headerlink&quot; title=&quot;函数式编程是什么&quot;&gt;&lt;/a&gt;函数式编程是什么&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;函数式编程，是一种使用函数进行编程的方式，一个“函数”对应于一个数
      
    
    </summary>
    
      <category term="Java基础" scheme="https://challange.github.io/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="DIY" scheme="https://challange.github.io/tags/DIY/"/>
    
      <category term="Lambda表达式" scheme="https://challange.github.io/tags/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    
      <category term="Java基础" scheme="https://challange.github.io/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud——Gateway跨域配置</title>
    <link href="https://challange.github.io/springcloud-SpringCloud%E2%80%94%E2%80%94Gateway%E8%B7%A8%E5%9F%9F%E9%85%8D%E7%BD%AE/"/>
    <id>https://challange.github.io/springcloud-SpringCloud——Gateway跨域配置/</id>
    <published>2019-05-05T08:05:05.000Z</published>
    <updated>2019-05-05T08:15:10.444Z</updated>
    
    <content type="html"><![CDATA[<h3 id="正确配置方法"><a href="#正确配置方法" class="headerlink" title="正确配置方法"></a>正确配置方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 配置跨域</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CorsWebFilter <span class="title">corsFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CorsConfiguration config = <span class="keyword">new</span> CorsConfiguration();</span><br><span class="line">    <span class="comment">// cookie跨域</span></span><br><span class="line">    config.setAllowCredentials(Boolean.TRUE);</span><br><span class="line">    config.addAllowedMethod(<span class="string">"*"</span>);</span><br><span class="line">    config.addAllowedOrigin(<span class="string">"*"</span>);</span><br><span class="line">    config.addAllowedHeader(<span class="string">"*"</span>);</span><br><span class="line">    <span class="comment">// 配置前端js允许访问的自定义响应头</span></span><br><span class="line">    config.addExposedHeader(<span class="string">"setToken"</span>);</span><br><span class="line"></span><br><span class="line">    UrlBasedCorsConfigurationSource source = <span class="keyword">new</span> UrlBasedCorsConfigurationSource(<span class="keyword">new</span> PathPatternParser());</span><br><span class="line">    source.registerCorsConfiguration(<span class="string">"/**"</span>, config);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CorsWebFilter(source);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置不生效方法"><a href="#配置不生效方法" class="headerlink" title="配置不生效方法"></a>配置不生效方法</h3><ul><li><a href="https://cloud.spring.io/spring-cloud-static/spring-cloud-gateway/2.1.0.RELEASE/single/spring-cloud-gateway.html#_cors_configuration">官方推荐配置</a></li><li>自定义实现GlobalFilter无效</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;正确配置方法&quot;&gt;&lt;a href=&quot;#正确配置方法&quot; class=&quot;headerlink&quot; title=&quot;正确配置方法&quot;&gt;&lt;/a&gt;正确配置方法&lt;/h3&gt;&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutt
      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://challange.github.io/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://challange.github.io/tags/SpringCloud/"/>
    
      <category term="Gateway" scheme="https://challange.github.io/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>SpringCloud——Gateway配置大全</title>
    <link href="https://challange.github.io/springcloud-SpringCloud%E2%80%94%E2%80%94Gateway%E9%85%8D%E7%BD%AE%E5%A4%A7%E5%85%A8/"/>
    <id>https://challange.github.io/springcloud-SpringCloud——Gateway配置大全/</id>
    <published>2019-04-07T08:36:59.000Z</published>
    <updated>2019-04-07T08:44:25.545Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>了解Gateway的配置才可以理解使用Gateway可以做什么事情，才能更好地应用在产品开发中。</p></blockquote><h3 id="Predicates"><a href="#Predicates" class="headerlink" title="Predicates"></a>Predicates</h3><blockquote><p>Predicates主要起的作用是：配置路由匹配请求的规则</p></blockquote><h4 id="Http相关"><a href="#Http相关" class="headerlink" title="Http相关"></a>Http相关</h4><h5 id="Path"><a href="#Path" class="headerlink" title="Path"></a>Path</h5><blockquote><p>配置对于请求路径的匹配规则</p></blockquote><ol><li><p>yml配置，多个参数用逗号隔开</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Path</span> <span class="string">=</span> <span class="string">/aa/**,/bb/**</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Path"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"pattern"</span>:<span class="string">"/aa/**"</span>,<span class="attr">"pattern1"</span>:<span class="string">"/bb/**"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><blockquote><p>配置对Cookie中值的匹配，第一个为key，第二个为value。下例匹配cookie设置chocolate:ch.p的请求</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Cookie</span> <span class="string">=</span> <span class="string">chocolate,ch.p</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Cookie"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"chocolate"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"ch.p"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h5><blockquote><p>匹配Http请求中设置的内容，http-header设置X-Request-Id:\d+可以匹配，第二个参数第二个参数是正则表达式</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Header</span> <span class="string">=</span> <span class="string">X-Request-Id,\d+</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Header"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Request-Id"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"\d+"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Host"><a href="#Host" class="headerlink" title="Host"></a>Host</h5><blockquote><p>匹配Http请求Host，匹配所有host为**.somehost.com的请求</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Host</span> <span class="string">=</span> <span class="string">**.somehost.com</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Host"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"**.somehost.com"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h5><blockquote><p>匹配Http请求头</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Method</span> <span class="string">=</span> <span class="string">GET</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Method"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"GET"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Query"><a href="#Query" class="headerlink" title="Query"></a>Query</h5><blockquote><p>匹配Http请求中的查询参数，请求中携带param1=value的请求可以匹配</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Query</span> <span class="string">=</span> <span class="string">param1,value</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Query"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"param1"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"value"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="RemoteAddr"><a href="#RemoteAddr" class="headerlink" title="RemoteAddr"></a>RemoteAddr</h5><blockquote><p>匹配请求中的RemoteAddr</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RemoteAddr</span> <span class="string">=</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.1</span><span class="string">/24</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RemoteAddr"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"192.168.1.1/24"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="时间相关"><a href="#时间相关" class="headerlink" title="时间相关"></a>时间相关</h4><h5 id="After"><a href="#After" class="headerlink" title="After"></a>After</h5><blockquote><p>设置时间之后可以访问</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">After</span> <span class="string">=</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-20</span><span class="attr">T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"After"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"2017-01-20T17:42:47.789-07:00[America/Denver]"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Before"><a href="#Before" class="headerlink" title="Before"></a>Before</h5><blockquote><p>设置时间之前可以访问</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Before</span> <span class="string">=</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-20</span><span class="attr">T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Before"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"2017-01-20T17:42:47.789-07:00[America/Denver]"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h5 id="Before-1"><a href="#Before-1" class="headerlink" title="Before"></a>Before</h5><blockquote><p>设置时间段内可以访问</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Between</span> <span class="string">=</span> <span class="number">2017</span><span class="bullet">-01</span><span class="bullet">-20</span><span class="attr">T17:42:47.789-07:00[America/Denver],2017-01-21T17:42:47.789-07:00[America/Denver]</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Between"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"2017-01-20T17:42:47.789-07:00[America/Denver]"</span>，<span class="string">"_genkey_1"</span>:<span class="string">"2017-01-21T17:42:47.789-07:00[America/Denver]"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="权重路由"><a href="#权重路由" class="headerlink" title="权重路由"></a>权重路由</h4><blockquote><p>至少两组以上路由可以配置权重路由，配置后会根据权重随机访问几个路由</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">Weight</span> <span class="string">=</span> <span class="string">service1,80</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Weight"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"service1"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"80"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="Filters"><a href="#Filters" class="headerlink" title="Filters"></a>Filters</h3><h4 id="路径重写"><a href="#路径重写" class="headerlink" title="路径重写"></a>路径重写</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RewritePath</span> <span class="string">=</span> <span class="string">/path/(?&lt;segment&gt;.*),</span> <span class="string">/$\&#123;segment&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RewritePath"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"/foo/(?&lt;segment&gt;.*)"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"/$\\&#123;segment&#125;"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改请求头"><a href="#修改请求头" class="headerlink" title="修改请求头"></a>修改请求头</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">AddRequestHeader</span> <span class="string">=</span> <span class="string">X-Request-Foo,Bar</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"AddRequestHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Request-Foo"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"Bar"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改请求参数"><a href="#修改请求参数" class="headerlink" title="修改请求参数"></a>修改请求参数</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">AddRequestParameter</span> <span class="string">=</span> <span class="string">foo,bar</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"AddRequestParameter"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"foo"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"bar"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="修改响应参数"><a href="#修改响应参数" class="headerlink" title="修改响应参数"></a>修改响应参数</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">AddResponseHeader</span> <span class="string">=</span> <span class="string">X-Request-Foo,Bar</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"AddResponseHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Request-Foo"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"Bar"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="路径前缀增强"><a href="#路径前缀增强" class="headerlink" title="路径前缀增强"></a>路径前缀增强</h4><blockquote><p>请求路径/hello, 将会被替换为 /mypath/hello</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">PrefixPath</span> <span class="string">=</span> <span class="string">/mypath</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"PrefixPath"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"/mypath"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="路径前缀删除"><a href="#路径前缀删除" class="headerlink" title="路径前缀删除"></a>路径前缀删除</h4><blockquote><p>请求/name/bar/foo，去除掉前面两个前缀之后，最后转发到目标服务的路径为/foo</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">StripPrefix</span> <span class="string">=</span> <span class="number">2</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"StripPrefix"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"2"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="请求携带保留原始Host"><a href="#请求携带保留原始Host" class="headerlink" title="请求携带保留原始Host"></a>请求携带保留原始Host</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">PreserveHostHeader</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"PreserveHostHeader"</span>,<span class="attr">"args"</span>:&#123;&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RedirectTo</span> <span class="string">=</span> <span class="number">302</span><span class="string">,http://acme.org</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RedirectTo"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"302"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"http://acme.org"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="断路器"><a href="#断路器" class="headerlink" title="断路器"></a>断路器</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Hystrix</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line">  <span class="comment"># 断路后跳转地址</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">fallbackcmd</span></span><br><span class="line"><span class="attr">      fallbackUri:</span> <span class="attr">forward:/incaseoffailureusethis</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"Hystrix"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"name"</span>:<span class="string">"fallbackcmd"</span>,<span class="attr">"fallbackUri"</span>:<span class="string">"forward:/incaseoffailureusethis"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="集成Redis原生支持请求限流"><a href="#集成Redis原生支持请求限流" class="headerlink" title="集成Redis原生支持请求限流"></a>集成Redis原生支持请求限流</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">RequestRateLimiter</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line">    <span class="string">redis-rate-limiter.replenishRate:</span> <span class="number">10</span>  </span><br><span class="line">    <span class="string">redis-rate-limiter.burstCapacity:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RequestRateLimiter"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"redis-rate-limiter.replenishRate"</span>:<span class="string">"10"</span>,<span class="attr">"redis-rate-limiter.burstCapacity"</span>:<span class="string">"20"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="删除请求头属性"><a href="#删除请求头属性" class="headerlink" title="删除请求头属性"></a>删除请求头属性</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RemoveRequestHeader</span> <span class="string">=</span> <span class="string">X-Request-Foo</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RemoveRequestHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Request-Foo"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="删除响应头属性"><a href="#删除响应头属性" class="headerlink" title="删除响应头属性"></a>删除响应头属性</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RemoveResponseHeader</span> <span class="string">=</span> <span class="string">X-Request-Foo</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RemoveResponseHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Request-Foo"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="重写响应头"><a href="#重写响应头" class="headerlink" title="重写响应头"></a>重写响应头</h4><blockquote><p>将请求 /42?user=ford&amp;password=omg!what&amp;flag=true, 改为 /42?user=ford&amp;password=***&amp;flag=true</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">RewriteResponseHeader</span> <span class="string">=</span> <span class="string">X-Response-Foo,password=[^&amp;]+,password=***</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RewriteResponseHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Response-Foo"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"password=[^&amp;]+"</span>,<span class="attr">"_genkey_2"</span>:<span class="string">"password=***"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="重设请求路径"><a href="#重设请求路径" class="headerlink" title="重设请求路径"></a>重设请求路径</h4><blockquote><p>请求/foo/bar，在接下来的处理中被改为/bar</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">SetPath</span> <span class="string">=/&#123;segment&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"SetPath"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"/&#123;segment&#125;"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="设置响应头"><a href="#设置响应头" class="headerlink" title="设置响应头"></a>设置响应头</h4><blockquote><p>在接下来的处理中修改响应头X-Response-Foo为Bar</p></blockquote><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="string">SetResponseHeader</span> <span class="string">=X-Request-Foo,Bar</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"SetResponseHeader"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"X-Response-Foo"</span>,<span class="attr">"_genkey_1"</span>:<span class="string">"Bar"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="设置Http状态"><a href="#设置Http状态" class="headerlink" title="设置Http状态"></a>设置Http状态</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">SetStatus</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line">  <span class="attr">status:</span> <span class="number">401</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"SetStatus"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"302"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="设置文件传输大小"><a href="#设置文件传输大小" class="headerlink" title="设置文件传输大小"></a>设置文件传输大小</h4><ol><li><p>yml配置</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">RequestSize</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line"><span class="attr">   maxSize:</span> <span class="number">5000000</span></span><br></pre></td></tr></table></figure></li><li><p>json配置</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;<span class="attr">"name"</span>:<span class="string">"RequestSize"</span>,<span class="attr">"args"</span>:&#123;<span class="attr">"_genkey_0"</span>:<span class="string">"5000000"</span>&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="失败重试"><a href="#失败重试" class="headerlink" title="失败重试"></a>失败重试</h4><ol><li>yml配置<figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">- name:</span> <span class="string">Retry</span></span><br><span class="line"><span class="attr">  args:</span></span><br><span class="line">  <span class="attr">retries:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">      statuses:</span> <span class="string">BAD_GATEWAY</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;了解Gateway的配置才可以理解使用Gateway可以做什么事情，才能更好地应用在产品开发中。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Predicates&quot;&gt;&lt;a href=&quot;#Predicates&quot; class=&quot;headerli
      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://challange.github.io/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://challange.github.io/tags/SpringCloud/"/>
    
      <category term="Gateway" scheme="https://challange.github.io/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>从零开始玩转SpringCloud（二）：Gateway网关对接注册中心</title>
    <link href="https://challange.github.io/springcloud-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%8E%A9%E8%BD%ACSpringCloud%EF%BC%88%E4%BA%8C%EF%BC%89%EF%BC%9AGateway%E7%BD%91%E5%85%B3%E5%AF%B9%E6%8E%A5%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>https://challange.github.io/springcloud-从零开始玩转SpringCloud（二）：Gateway网关对接注册中心/</id>
    <published>2019-04-07T06:54:30.000Z</published>
    <updated>2019-04-07T06:58:46.810Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简介：Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。</p></blockquote><h3 id="项目搭建"><a href="#项目搭建" class="headerlink" title="项目搭建"></a>项目搭建</h3><ol><li>引入依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--Eureka 客户端--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--Gateway 路由--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-gateway<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><blockquote><p>注意：不要引入spring-boot-starter-web包，会导致Gateway启动抛出异常，错误如下。因为Spring Cloud Gateway 是使用 netty+webflux实现，webflux与web是冲突的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Consider defining a bean of type &apos;org.springframework.http.codec.ServerCodecConfigurer&apos; in your configuration.</span><br></pre></td></tr></table></figure></p></blockquote><ol start="2"><li><p>在Application中使用@EnableEurekaClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.gateway;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.EnableEurekaClient;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GatewayApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(GatewayApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>配置自动将注册中心的服务映射为路由</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">gateway</span></span><br><span class="line"><span class="attr">  cloud:</span></span><br><span class="line"><span class="attr">    gateway:</span></span><br><span class="line">      <span class="comment"># 此处配置表示开启自动映射Eureka下发的路由</span></span><br><span class="line"><span class="attr">      discovery:</span></span><br><span class="line"><span class="attr">        locator:</span></span><br><span class="line"><span class="attr">          enabled:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">          lowerCaseServiceId:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line">    <span class="comment"># Eureka Server地址</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8760/eureka/</span></span><br></pre></td></tr></table></figure></li><li><p>至此，已经可以直接通过gateway访问其他注册在Eureka中的服务的接口了。如客户端接口地址：<a href="http://localhost:8080/test，注册名称为client，则访问地址为http://localhost:8081/client/test。">http://localhost:8080/test，注册名称为client，则访问地址为http://localhost:8081/client/test。</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简介：Spring Cloud Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;项目搭建&quot;&gt;&lt;a href=&quot;#项目搭建&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://challange.github.io/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://challange.github.io/tags/SpringCloud/"/>
    
      <category term="Gateway" scheme="https://challange.github.io/tags/Gateway/"/>
    
  </entry>
  
  <entry>
    <title>从零开始玩转SpringCloud（一）：Eureka注册中心</title>
    <link href="https://challange.github.io/springcloud-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E7%8E%A9%E8%BD%ACSpringCloud%EF%BC%88%E4%B8%80%EF%BC%89%EF%BC%9AEureka%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83/"/>
    <id>https://challange.github.io/springcloud-从零开始玩转SpringCloud（一）：Eureka注册中心/</id>
    <published>2019-04-07T06:50:20.000Z</published>
    <updated>2019-04-07T08:53:50.341Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Eureka"><a href="#Eureka" class="headerlink" title="Eureka"></a>Eureka</h3><hr><blockquote><p>介绍：Eureka，古希腊词语，含义为我找到了，我发现了！相传阿基米德发现福利原理时说出了这个词。</p></blockquote><p>Eureka是Spring Cloud Netflix微服务套件中的一部分，可以与Springboot构建的微服务很容易的整合起来。Eureka包含了服务器端和客户端组件。服务器端，也被称作是服务注册中心，用于提供服务的注册与发现。Eureka支持高可用的配置，当集群中有分片出现故障时，Eureka就会转入自动保护模式，它允许分片故障期间继续提供服务的发现和注册，当故障分片恢复正常时，集群中其他分片会把他们的状态再次同步回来。客户端组件包含服务消费者与服务生产者。在应用程序运行时，Eureka客户端向注册中心注册自身提供的服务并周期性的发送心跳来更新它的服务租约。同时也可以从服务端查询当前注册的服务信息并把他们缓存到本地并周期性的刷新服务状态。</p><h4 id="Eureka-Server服务搭建"><a href="#Eureka-Server服务搭建" class="headerlink" title="Eureka-Server服务搭建"></a>Eureka-Server服务搭建</h4><hr><ol><li>引入依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Application中使用@EnableEurekaServer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaServer</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span> <span class="comment"># cAPP名称，在Eureka注册名称</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">peer</span> </span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer</span> <span class="comment"># 服务注册中心实例的主机名</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    register-with-eureka:</span> <span class="literal">false</span>  <span class="comment"># 是否注册自己</span></span><br><span class="line"><span class="attr">    fetch-registry:</span> <span class="literal">false</span></span><br><span class="line"><span class="attr">    serviceUrl:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://$&#123;eureka.instance.hostname&#125;:$&#123;server.port&#125;/eureka/</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enableSelfPreservation:</span> <span class="literal">false</span> <span class="comment">#关闭自我保护机制</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      netflix:</span></span><br><span class="line"><span class="attr">        eureka:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">        discovery:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8760</span></span><br></pre></td></tr></table></figure><p>至此一个Eureka-Server就搭建好了。</p><h4 id="Eureka-Server服务高可用"><a href="#Eureka-Server服务高可用" class="headerlink" title="Eureka-Server服务高可用"></a>Eureka-Server服务高可用</h4><blockquote><p>说到高可用，就是要保证一个节点挂掉，不会影响整个系统的运行。解决办法就是多部署几个实例，搭建集群，那么一个实例节点挂掉，其他实例仍可提供服务。</p></blockquote><ol><li>新建三个配置文件application-peer1.yml、application-peer2.yml、application-peer3，</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">peer1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer1</span> <span class="comment">#服务注册中心实例的主机名</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span>     <span class="comment"># 另外几个注册中心地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8762/eureka,</span> <span class="attr">http://localhost:8763/eureka</span>  </span><br><span class="line"><span class="attr">    server:</span></span><br><span class="line"><span class="attr">      enableSelfPreservation:</span> <span class="literal">false</span> <span class="comment">#关闭自我保护</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      netflix:</span></span><br><span class="line"><span class="attr">        eureka:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">        discovery:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8761</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">peer2</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer2</span> <span class="comment">#服务注册中心实例的主机名</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span>  <span class="comment"># 另外几个注册中心地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka,</span> <span class="attr">http://localhost:8763/eureka</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enableSelfPreservation:</span> <span class="literal">false</span> <span class="comment">#关闭自我保护</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      netflix:</span></span><br><span class="line"><span class="attr">        eureka:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">        discovery:</span> <span class="string">info</span></span><br><span class="line">        </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8762</span></span><br></pre></td></tr></table></figure><hr><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span></span><br><span class="line"><span class="attr">  profiles:</span></span><br><span class="line"><span class="attr">    active:</span> <span class="string">peer3</span></span><br><span class="line"></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    hostname:</span> <span class="string">peer3</span> <span class="comment">#服务注册中心实例的主机名</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    serviceUrl:</span>  <span class="comment"># 另外几个注册中心地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8761/eureka,</span> <span class="attr">http://localhost:8762/eureka</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enableSelfPreservation:</span> <span class="literal">false</span> <span class="comment">#关闭自我保护</span></span><br><span class="line"></span><br><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line"><span class="attr">    com:</span></span><br><span class="line"><span class="attr">      netflix:</span></span><br><span class="line"><span class="attr">        eureka:</span> <span class="string">info</span></span><br><span class="line"><span class="attr">        discovery:</span> <span class="string">info</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8763</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>idea下按配置文件启动多个项目，Active profiles指定启动配置文件。分别启动刚刚写好的三个配置文件即可。<br><img src="/images/从零开始玩转SpringCloud（一）：Eureka注册中心/1.png" alt="在这里插入图片描述"></p></li><li><p>生产环境下是否需要动态配置注册中心，目前的配置对生产环境动态配置非常不友好</p></li></ol><h4 id="客户端配置"><a href="#客户端配置" class="headerlink" title="客户端配置"></a>客户端配置</h4><ol><li>引入Eureka Client依赖</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>在Application中使用@EnableEurekaServer</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.example.eureka;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.cloud.netflix.eureka.server.EnableEurekaServer;</span><br><span class="line"></span><br><span class="line"><span class="meta">@EnableEurekaClient</span></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaClientApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(EurekaClientApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>配置文件</li></ol><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">gateway</span>  <span class="comment"># 在eureka-server注册名称</span></span><br><span class="line">  </span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://localhost:8760/eureka/</span> </span><br><span class="line"><span class="comment">#      #高可用配置</span></span><br><span class="line"><span class="comment">#      defaultZone: http://localhost:8761/eureka/,http://localhost:8762/eureka/,http://localhost:8763/eureka/ </span></span><br><span class="line">      </span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br></pre></td></tr></table></figure><ol start="4"><li>至此已EurekaClient已经搭建成功</li></ol><p><img src="/images/从零开始玩转SpringCloud（一）：Eureka注册中心/2.png" alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Eureka&quot;&gt;&lt;a href=&quot;#Eureka&quot; class=&quot;headerlink&quot; title=&quot;Eureka&quot;&gt;&lt;/a&gt;Eureka&lt;/h3&gt;&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;介绍：Eureka，古希腊词语，含义为我找到了，我发现了！相传阿基米德发
      
    
    </summary>
    
      <category term="SpringCloud" scheme="https://challange.github.io/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="https://challange.github.io/tags/SpringCloud/"/>
    
      <category term="Eureka" scheme="https://challange.github.io/tags/Eureka/"/>
    
  </entry>
  
  <entry>
    <title>Scratch3.0——作品截图</title>
    <link href="https://challange.github.io/scratch-Scratch3-0%E2%80%94%E2%80%94%E4%BD%9C%E5%93%81%E6%88%AA%E5%9B%BE/"/>
    <id>https://challange.github.io/scratch-Scratch3-0——作品截图/</id>
    <published>2019-04-06T08:46:31.000Z</published>
    <updated>2019-04-07T08:56:35.339Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>Scratch 的舞台是基于canvas，最初尝试直接通过canvas的dom，然后生成图片，但最后只能得到一个黑色的图片，得到黑色图片的原因是没有取到有效的canvas而不是因为图片跨域，当初在这里走了很多弯路，继续研究舞台组件stage.jsx，从vm.renderer可以获取canvas，于是通过这个canvas对象生成图片，记得当时的效果是偶尔会得到有效图片，但是大部分时候依然是黑色的图片，原因稍后回解释。为了实现截图，当时又进一步研究了renderer的代码，最后找到了draw方法，通过多次尝试发现<strong>在draw方法的最后执行canvas对象生成图片可以获得舞台的有效图片</strong>。</p></blockquote><h4 id="最初的笨办法"><a href="#最初的笨办法" class="headerlink" title="最初的笨办法"></a>最初的笨办法</h4><p>在node_modules中找到scratch-render/src/RenderWebGL.js中的draw方法，也可以直接在dist中修改编译后的文件。顺便解释一下draw是对舞台进行了清理和重新绘制，而draw的频率非常频繁，因此不能直接通过canvas获取图片。在重绘后追加获取图片的toDataURL方法，考虑到需要在gui里面调用，此处采用了监听键盘事件来通信，接收到截图请求将舞台图片放在window.sessionStorage内存中，在需要使用的时候可以直接从sessionStorage获得。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">draw () &#123;</span><br><span class="line">       <span class="keyword">this</span>._doExitDrawRegion();</span><br><span class="line"><span class="comment">// 获取gl</span></span><br><span class="line">       <span class="keyword">const</span> gl = <span class="keyword">this</span>._gl;</span><br><span class="line"><span class="comment">// </span></span><br><span class="line">       twgl.bindFramebufferInfo(gl, <span class="literal">null</span>);</span><br><span class="line">       gl.viewport(<span class="number">0</span>, <span class="number">0</span>, gl.canvas.width, gl.canvas.height);</span><br><span class="line">       gl.clearColor.apply(gl, <span class="keyword">this</span>._backgroundColor);</span><br><span class="line">       gl.clear(gl.COLOR_BUFFER_BIT);</span><br><span class="line"><span class="comment">// 重新绘制</span></span><br><span class="line">       <span class="keyword">this</span>._drawThese(<span class="keyword">this</span>._drawList, ShaderManager.DRAW_MODE.default, <span class="keyword">this</span>._projection);</span><br><span class="line">       <span class="comment">// 增加如下代码</span></span><br><span class="line">       <span class="keyword">let</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">       img.src = gl.canvas.toDataURL(<span class="string">'image/png'</span>,<span class="number">0.7</span>)</span><br><span class="line">       <span class="built_in">document</span>.onkeydown = <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(e.keyCode == <span class="number">16</span>)&#123;</span><br><span class="line">               <span class="built_in">window</span>.sessionStorage.setItem(<span class="string">"coverImg"</span>,img.src)</span><br><span class="line">               <span class="built_in">console</span>.log(<span class="string">'webGL'</span>)</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h4 id="带来问题"><a href="#带来问题" class="headerlink" title="带来问题"></a>带来问题</h4><ol><li>直接修改node_modules依赖的内容，严重影响团队开发、项目部署，提升了项目维护的复杂度。</li><li>每次draw都会执行toDataURL方法，并且赋值，增大了系统开销。</li><li>通过事件映射，提升了项目的复杂度。</li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>回归最初问题的本源，不能直接从canvas.toDataURL获得舞台截图的原因是执行toDataURL的时候可能正好draw在重绘。因此先截图前先draw然后获取图片。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.renderer.draw();</span><br><span class="line"><span class="keyword">const</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">img.src = <span class="keyword">this</span>.canvas.toDataURL(<span class="string">'image/png'</span>, <span class="number">0.7</span>);</span><br></pre></td></tr></table></figure></p><p>码猿Scratch学习平台：<a href="https://scratch.imayuan.com">https://scratch.imayuan.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;Scratch 的舞台是基于canvas，最初尝试直接通过canvas的dom，然后生成图片，但最后只能得到一个黑色的图片，得到黑色图片的原因是没有取到有效的canvas而不是因为图片跨域，当初在这里走了很多弯路，继续研究舞台组件stage.jsx
      
    
    </summary>
    
      <category term="Scratch" scheme="https://challange.github.io/categories/Scratch/"/>
    
    
      <category term="Scratch" scheme="https://challange.github.io/tags/Scratch/"/>
    
  </entry>
  
  <entry>
    <title>Scratch3.0——克隆代码仓库的正确姿势</title>
    <link href="https://challange.github.io/scratch-Scratch3-0%E2%80%94%E2%80%94%E5%85%8B%E9%9A%86%E4%BB%A3%E7%A0%81%E4%BB%93%E5%BA%93%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://challange.github.io/scratch-Scratch3-0——克隆代码仓库的正确姿势/</id>
    <published>2019-04-06T08:46:31.000Z</published>
    <updated>2019-04-07T09:02:09.586Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>对Scratch3.0进行二次开发，首先要在github上fock<a href="https://github.com/LLK/scratch-gui.git">官方代码</a>，但是在自己开发的同时又要跟进官方的代码就要在git做如下配置。</p></blockquote><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><p>1、配置上游项目地址。即将你 fork 的项目的地址给配置到自己的项目上。使用以下命令来配置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote add upstream https://github.com/LLK/scratch-gui.git</span><br></pre></td></tr></table></figure></p><p>然后可以查看一下配置状况，很好，上游项目的地址已经被加进来了。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">➜ git remote -v</span><br><span class="line">origin https://github.com/***/scratch-gui.git (fetch)</span><br><span class="line">origin  https://github.com/***/scratch-gui.git (push)</span><br><span class="line">upstream        https://github.com/LLK/scratch-gui.git (fetch)</span><br><span class="line">upstream        https://github.com/LLK/scratch-gui.git (push)</span><br></pre></td></tr></table></figure></p><p>2、获取上游(官方)项目更新。使用 fetch 命令更新，fetch 后会被存储在一个本地分支 upstream/master 上。如果长时间没有更新，可能会非常慢，一定要在网络环境好的情况下更新或从GitHub下载代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git fetch upstream</span><br></pre></td></tr></table></figure></p><p>3、合并到本地分支。切换到 master 分支，合并 upstream/master 分支。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git merge upstream/master</span><br></pre></td></tr></table></figure></p><p>如果提示： fatal: refusing to merge unrelated histories，这是因为本地和远端已经是两个独立的版本库，git认为是不相干的版本库。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git merge upstream/master --allow-unrelated-histories</span><br></pre></td></tr></table></figure></p><p>4、合并冲突。因为是在原先代码的基础上二次开发，冲突不可避免，而最费时间的也是这里解决冲突这一步。</p><p>5、提交推送。根据自己情况提交推送自己项目的代码。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜ git push origin master</span><br></pre></td></tr></table></figure></p><p>由于项目已经配置了上游项目的地址，所以如果 fork 的项目再次更新，重复步骤 2、3、4即可。</p><h4 id="留几个问题供大家思考交流："><a href="#留几个问题供大家思考交流：" class="headerlink" title="留几个问题供大家思考交流："></a>留几个问题供大家思考交流：</h4><ol><li>冲突在所难免，在开发中注意什么可以更快更高效的解决冲突合并代码？</li><li>如果官方代码重构了某部分模块，你的代码严重依赖该模块该如何处理？</li></ol><blockquote><p>如果需要修改开源系统，不要改动原系统，而是要开发辅助系统。（——从零开始学架构）</p></blockquote><p>码猿Scratch学习平台：<a href="https://scratch.imayuan.com">https://scratch.imayuan.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;对Scratch3.0进行二次开发，首先要在github上fock&lt;a href=&quot;https://github.com/LLK/scratch-gui.git&quot;&gt;官方代码&lt;/a&gt;，但是在自己开发的同时又要跟进官方的代码就要在git做如下配置。&lt;/
      
    
    </summary>
    
      <category term="Scratch" scheme="https://challange.github.io/categories/Scratch/"/>
    
    
      <category term="Scratch" scheme="https://challange.github.io/tags/Scratch/"/>
    
  </entry>
  
  <entry>
    <title>Scratch3.0——项目层次结构</title>
    <link href="https://challange.github.io/scratch-Scratch3-0%E2%80%94%E2%80%94%E9%A1%B9%E7%9B%AE%E5%B1%82%E6%AC%A1%E7%BB%93%E6%9E%84/"/>
    <id>https://challange.github.io/scratch-Scratch3-0——项目层次结构/</id>
    <published>2019-04-06T08:46:31.000Z</published>
    <updated>2019-04-07T09:05:43.386Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>简要介绍: 本文旨在介绍scratch3.0项目层次结构及关键功能。<br>源码：<a href="https://github.com/LLK/scratch-gui">https://github.com/LLK/scratch-gui</a></p></blockquote><p><strong>核心依赖库</strong><br><img src="/images/Scratch3-0——项目层次结构/1.png" alt="Alt text"><br>scratch-audio：声音拓展<br>scratch-blocks：代码积木块<br>scratch-l10n：国际化<br>scratch-paint：绘图拓展<br>scratch-render：舞台渲染，在舞台区域出现的基于WebGL的处理器。<br>scratch-storage：作品存储加载<br>scratch-svg-renderer：svg处理<br>scratch-vm：虚拟机，管理状态并执行业务逻辑。</p><h4 id="Scratch-Gui目录结构"><a href="#Scratch-Gui目录结构" class="headerlink" title="Scratch-Gui目录结构"></a>Scratch-Gui目录结构</h4><p>在scratch中最为核心的便是gui库，目录结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">├── build                    # 默认编译后的文件夹</span><br><span class="line">│   ├── static               # 静态资源</span><br><span class="line">│   ├── index.html          </span><br><span class="line">│   ├── gui.js               </span><br><span class="line">│   ├── lib.js               # 编译后主要的js文件                    </span><br><span class="line">├── src</span><br><span class="line">│   ├── components           # UI组件，负责页面呈现</span><br><span class="line">│   ├── containers           # 容器组件，承载容器组件业务逻辑</span><br><span class="line">│   ├── css                  # 全局通用css</span><br><span class="line">│   ├── examples             # 集成测试用例</span><br><span class="line">│   ├── extensions       # 拓展案例</span><br><span class="line">│   ├── lib                  # 插件及高阶组件</span><br><span class="line">│   ├── audio            # 声音插件</span><br><span class="line">│   ├── backpack         # 背包插件</span><br><span class="line">│   ├── default-project  # 默认项目</span><br><span class="line">│   ├── libraries        # 素材库相关</span><br><span class="line">│   ├── video            # 视频模块</span><br><span class="line">│   ├── playground           # 编译后页面的模版</span><br><span class="line">│   ├── reducers             # 全局状态控制</span><br><span class="line">├── test                     # 测试用例</span><br><span class="line">├── translations             # 翻译库</span><br><span class="line">├── README.md</span><br><span class="line">└── package.json</span><br><span class="line">└── webpack.consig.js</span><br></pre></td></tr></table></figure></p><p>码猿Scratch学习平台：<a href="https://scratch.imayuan.com">https://scratch.imayuan.com</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;简要介绍: 本文旨在介绍scratch3.0项目层次结构及关键功能。&lt;br&gt;源码：&lt;a href=&quot;https://github.com/LLK/scratch-gui&quot;&gt;https://github.com/LLK/scratch-gui&lt;/a&gt;
      
    
    </summary>
    
      <category term="Scratch" scheme="https://challange.github.io/categories/Scratch/"/>
    
    
      <category term="Scratch" scheme="https://challange.github.io/tags/Scratch/"/>
    
  </entry>
  
</feed>
